/*
 * Copyright (c) Huawei Technologies Co., Ltd. 2025. All rights reserved.
 * This source file is part of the Cangjie project, licensed under Apache-2.0
 * with Runtime Library Exception.
 *
 * See https://cangjie-lang.cn/pages/LICENSE for license information.
 */

package stdx.logger

import std.collection.ArrayList
import std.io.OutputStream
import std.sync.AtomicBool
import stdx.log.*

enum LogStyle {
    | SIMPLE
    | TEXT
    | JSON
}

class CommonLogger <: Logger {
    let _attrs = ArrayList<Attr>()
    var _level = LogLevel.INFO
    let _mode: LogStyle
    let o: OutputStream

    let _closed = AtomicBool(false)

    init(output: OutputStream, mode: LogStyle) {
        o = output
        _mode = mode
    }

    public mut prop level: LogLevel {
        get() {
            _level
        }
        set(v) {
            _level = v
        }
    }

    public func withAttrs(attrs: Array<Attr>): CommonLogger {
        if (attrs.size > 0) {
            let nl = this.clone()
            nl._attrs.add(all: attrs)
            return nl
        }
        return this
    }

    public func log(record: LogRecord): Unit {
        let _as = this._attrs.clone()
        _as.add(all: record.attrs)
        record.attrs = unsafe { _as.getRawArray() }
        match (_mode) {
            case LogStyle.SIMPLE => logSimple(record, o)
            case LogStyle.TEXT => logText(record, o)
            case LogStyle.JSON => logJson(record, o)
        }
    }

    public func isClosed(): Bool {
        _closed.load()
    }

    public func close(): Unit {
        if (isClosed()) {
            return
        }
        if (_closed.compareAndSwap(false, true)) {
            o.flush()
        }
    }
    
    func clone(): CommonLogger {
        let cl = CommonLogger(o, _mode)
        cl.level = this.level
        cl._attrs.add(all: this._attrs)
        return cl
    }
}

func writeLogRecordKeyValue(lw: LogWriter, record: LogRecord) {
    // write time
    lw.writeKey("time")
    lw.writeValue(record.time)
    // write level
    lw.writeKey("level")
    lw.writeValue(record.level.toString())
    // write message
    lw.writeKey("msg")
    lw.writeValue(record.message)
    // write source

    // write attrs
    for (i in 0..record.attrs.size) {
        let (key, value) = record.attrs[i]
        lw.writeKey(key)
        lw.writeValue(value)
    }
}

func logSimple(record: LogRecord, output: OutputStream): Unit {
    let tw: TextLogWriter = TextLogWriter(output)
    tw.start()
    // write time
    tw.writeMessage(record.time.toString())
    tw.writeMessage(' ')
    // write level
    tw.writeMessage(record.level.toString())
    tw.writeMessage(' ')
    // write message
    tw.writeMessage(record.message)
    tw.writeMessage(' ')
    // write source

    // write attrs
    for (i in 0..record.attrs.size) {
        let (key, value) = record.attrs[i]
        tw.writeKey(key)
        tw.writeValue(value)
    }
    tw.end()
    tw.flush()
}

func logText(record: LogRecord, output: OutputStream): Unit {
    let tw: TextLogWriter = TextLogWriter(output)
    tw.start()
    writeLogRecordKeyValue(tw, record)
    tw.end()
    tw.flush()
}

func logJson(record: LogRecord, output: OutputStream): Unit {
    let w: JsonLogWriter = JsonLogWriter(output)
    w.startObject()
    writeLogRecordKeyValue(w, record)
    w.endObject()
    w.flush()
}
