/*
 * Copyright (c) Huawei Technologies Co., Ltd. 2025. All rights reserved.
 * This source file is part of the Cangjie project, licensed under Apache-2.0
 * with Runtime Library Exception.
 *
 * See https://cangjie-lang.cn/pages/LICENSE for license information.
 */

package stdx.crypto.x509

import std.time.DateTime
import std.collection.{ArrayList, HashSet, contains, map, collectString, filter}
import std.fs.{Path, exists, File, Directory}

// Delete them after Cangjie support these types.
public type IP = Array<Byte>
const IPV4_SIZE: Int64 = 4
const IPV6_SIZE: Int64 = 16
const V_ASN1_UTF8STRING: Int32 = 12

public class X509Certificate <: Equatable<X509Certificate> & Hashable & ToString {
    private let blob: X509Blob

    init(blob: X509Blob) {
        this.blob = blob
    }

    // create Certificate from parent certificate
    public init(
        certificateInfo: X509CertificateInfo,
        parent!: X509Certificate,
        publicKey!: PublicKey,
        privateKey!: PrivateKey,
        signatureAlgorithm!: ?SignatureAlgorithm = None
    ) {
        unsafe {
            var cert = CPointer<Unit>()
            let digestPtr = getDigest(signatureAlgorithm)
            let rawPubKey = getRawPubKey(publicKey)
            let rawPriKey = getRawPriKey(privateKey)
            let rawIssuer = getRawName(parent.subject)
            var rawSubject = CPointer<Unit>()
            if (let Some(v) <- certificateInfo.subject) {
                rawSubject = getRawName(v)
            }
            let serialNumberStr = certificateInfo.serialNumber.toString()
            let notBeforeStr = getTimeString(certificateInfo.notBefore)
            let notAfterStr = getTimeString(certificateInfo.notAfter)
            let keyUsageStr = getKeyUsageString(certificateInfo.keyUsage)
            let extKeyUsageStr = getExtKeyUsageString(certificateInfo.extKeyUsage)
            let altNameStr = getAltNameString(
                certificateInfo.dnsNames,
                certificateInfo.emailAddresses,
                certificateInfo.IPAddresses
            )
            try (serialNumberCStr = LibC.mallocCString(serialNumberStr).asResource(), notBeforeCStr = LibC.mallocCString(
                notBeforeStr).asResource(), notAfterCStr = LibC.mallocCString(notAfterStr).asResource(), keyUsageCStr = LibC.
                mallocCString(keyUsageStr).asResource(), extKeyUsageCStr = LibC.mallocCString(extKeyUsageStr).asResource(
                ), altNameCStr = LibC.mallocCString(altNameStr).asResource(), certInfo = malloc<X509CertInfo>()) {
                if (!checkKeyType(rawPriKey, getKeyType(signatureAlgorithm))) {
                    throw X509Exception("X509Cert init failed: Private key type not match to signatureAlgorithm.")
                }
                certInfo.pointer.write(
                    X509CertInfo(
                        serialNumberCStr.value,
                        notBeforeCStr.value,
                        notAfterCStr.value,
                        altNameCStr.value,
                        keyUsageCStr.value,
                        extKeyUsageCStr.value
                    )
                )
                cert = createCert(rawPubKey, rawPriKey, rawIssuer, rawSubject, digestPtr, certInfo.pointer)
            } finally {
                if (!rawSubject.isNull()) {
                    nameFree(rawSubject)
                }
                nameFree(rawIssuer)
                keyFree(rawPriKey)
                keyFree(rawPubKey)
            }
            if (cert.isNull()) {
                throw X509Exception("X509Cert init failed: Cert info is null.")
            }
            var certBody = getCertBody(cert)
            blob = X509Blob(certBody)
            certFree(cert)
        }
    }

    public prop serialNumber: SerialNumber {
        get() {
            blob.serialNumber
        }
    }

    public prop signatureAlgorithm: SignatureAlgorithm {
        get() {
            blob.signatureAlgorithm
        }
    }

    public prop signature: Signature {
        get() {
            blob.signature
        }
    }

    public prop issuer: X509Name {
        get() {
            X509Name(blob.issuer)
        }
    }

    public prop subject: X509Name {
        get() {
            X509Name(blob.subject)
        }
    }

    public prop notBefore: DateTime {
        get() {
            blob.notBefore
        }
    }

    public prop notAfter: DateTime {
        get() {
            blob.notAfter
        }
    }

    public prop publicKeyAlgorithm: PublicKeyAlgorithm {
        get() {
            blob.publicKeyAlgorithm
        }
    }

    public prop publicKey: PublicKey {
        get() {
            CertPublicKey(blob)
        }
    }

    // Extensions
    public prop dnsNames: Array<String> {
        get() {
            blob.dnsNames
        }
    }

    public prop emailAddresses: Array<String> {
        get() {
            blob.emailAddresses
        }
    }

    public prop IPAddresses: Array<IP> {
        get() {
            blob.IPAddresses
        }
    }

    public prop keyUsage: KeyUsage {
        get() {
            blob.keyUsage
        }
    }

    public prop extKeyUsage: ExtKeyUsage {
        get() {
            blob.extKeyUsage
        }
    }

    public func encodeToPem(): PemEntry {
        PemEntry(PemEntry.LABEL_CERTIFICATE, encodeToDer())
    }

    public func encodeToDer(): DerBlob {
        blob.content
    }

    public static func decodeFromDer(der: DerBlob): X509Certificate {
        X509Certificate(X509Blob(der))
    }

    public static func decodeFromPem(pem: String): Array<X509Certificate> {
        let parsedPem = Pem.decode(pem)
        let result = ArrayBuilder<X509Certificate>(parsedPem.size)
        for (it in parsedPem) {
            if ((it.label == PemEntry.LABEL_CERTIFICATE || it.label == PemEntry.LABEL_TRUSTED_CERTIFICATE)) {
                if (let Some(v) <- it.body) {
                    result.append(decodeFromDer(v))
                }
            }
        }

        if (result.isEmpty()) {
            throw X509Exception("X509Cert decode failed: No ${PemEntry.LABEL_CERTIFICATE} entry found in PEM file.")
        }

        return result.toArray()
    }

    public static func systemRootCerts(): Array<X509Certificate> {
        getSystemRootCerts()
    }

    /**
     * Verify this cert by @verifyOption.
     *
     * return true if this cert is valid, otherwise return false, and
     * @throws X509Exception if failed.
     */
    public func verify(verifyOption: VerifyOption): Bool {
        // 1. Verify time in [notBefore, notAfter], optional.
        if (verifyOption.time < notBefore || verifyOption.time > notAfter) {
            return false
        }
        // 2. Verify dnsName in dnsNames, optional.  dnsName String 一个DNS extensions
        if (verifyOption.dnsName != "") {
            if (!(dnsNames |> contains<String>(verifyOption.dnsName))) {
                return false
            }
        }

        // 3. Verify the valid of [roots, intermediates, this] chains
        let roots = verifyOption.roots
        let intermediates = verifyOption.intermediates

        let rootsBlobs = Array<DerBlob>(roots.size) {i => roots[i].blob.content}
        let itermediateBlobs = Array<DerBlob>(intermediates.size) {i => intermediates[i].blob.content}
        let status = verifyCertChain(blob.content, rootsBlobs, itermediateBlobs)
        match {
            case status == 0i32 => false
            case status > 0i32 => true
            case _ => throw X509Exception("X509Cert verify failed: Internal resource problems or internal error.")
        }
    }

    public override func toString(): String {
        "X509Certificate(for=${subject}, valid in ${notBefore}..${notAfter}, issued by ${issuer})"
    }

    public override operator func ==(other: X509Certificate): Bool {
        this.blob == other.blob
    }

    public override operator func !=(other: X509Certificate): Bool {
        this.blob != other.blob
    }

    public override func hashCode(): Int64 {
        blob.hashCode()
    }
}

public class X509Name <: ToString {
    let blob: X500Principal

    init(blob: X500Principal) {
        this.blob = blob
    }

    public init(
        countryName!: ?String = None,
        provinceName!: ?String = None,
        localityName!: ?String = None,
        organizationName!: ?String = None,
        organizationalUnitName!: ?String = None,
        commonName!: ?String = None,
        email!: ?String = None
    ) {
        var name = nameNew()
        if (name.isNull()) {
            throw X509Exception("X509Name init failed: Cannot init a new X509Mame.")
        }
        try {
            setName(name, "countryName", nameString: countryName)
            setName(name, "stateOrProvinceName", nameString: provinceName)
            setName(name, "localityName", nameString: localityName)
            setName(name, "organizationName", nameString: organizationName)
            setName(name, "organizationalUnitName", nameString: organizationalUnitName)
            setName(name, "commonName", nameString: commonName)
            setName(name, "emailAddress", nameString: email)

            var parser = DerParser(getNameBody(name))
            var field = parser.parseNextDerField()
            this.blob = X500Principal(field)
        } finally {
            nameFree(name)
        }
    }

    private static func setName(name: CPointer<Unit>, nameType: String, nameString!: ?String = None) {
        match (nameString) {
            case None => return
            case Some(nameString) => setX509NameEntry(name, nameType, nameString)
        }
    }

    private static func setX509NameEntry(name: CPointer<Unit>, nameType: String, nameString: String): Unit {
        unsafe {
            try (nameTypePtr = LibC.mallocCString(nameType).asResource(), nameStringPtr = LibC.mallocCString(nameString).
                asResource()) {
                let ret = x509NameAddEntry(
                    name,
                    nameTypePtr.value,
                    V_ASN1_UTF8STRING,
                    nameStringPtr.value
                )
                if (ret <= 0) {
                    throw X509Exception("X509Name init failed: Set ${nameType} error.")
                }
            }
        }
    }

    private static func getNameBody(name: CPointer<Unit>): Array<Byte> {
        unsafe {
            var namelen = getNameDer(name, CPointer<CPointer<Byte>>())
            if (namelen < 0) {
                throw X509Exception("X509Name init failed: Cannot parse the X509 name body.")
            }
            var nameBody = Array<Byte>(Int64(namelen), repeat: 0)
            let data: CPointerHandle<Byte> = acquireArrayRawData(nameBody)
            try (namePtr = malloc<CPointer<Byte>>()) {
                namePtr.pointer.write(data.pointer)
                namelen = getNameDer(name, namePtr.pointer)
                if (namelen < 0) {
                    throw X509Exception("X509Name init failed: Cannot parse the X509 name body.")
                }
            } finally {
                releaseArrayRawData(data)
            }
            nameBody
        }
    }

    public prop countryName: ?String {
        get() {
            let field = blob.fieldById(PrincipalOids.COUNTRY_NAME) ?? return None
            field.asString()
        }
    }

    public prop provinceName: ?String {
        get() {
            let field = blob.fieldById(PrincipalOids.STATE_OR_PROVINCE_NAME) ?? return None
            field.asString()
        }
    }

    public prop localityName: ?String {
        get() {
            let field = blob.fieldById(PrincipalOids.LOCALITY_NAME) ?? return None
            field.asString()
        }
    }

    public prop organizationName: ?String {
        get() {
            let field = blob.fieldById(PrincipalOids.ORGANIZATION_NAME) ?? return None
            field.asString()
        }
    }

    public prop organizationalUnitName: ?String {
        get() {
            let field = blob.fieldById(PrincipalOids.ORGANIZATIONAL_UNIT_NAME) ?? return None
            field.asString()
        }
    }

    public prop commonName: ?String {
        get() {
            let field = blob.fieldById(PrincipalOids.COMMON_NAME) ?? return None
            field.asString()
        }
    }

    // sometime subject/issuer sequence has a email field.
    public prop email: ?String {
        get() {
            let field = blob.fieldById(PrincipalOids.EMAIL) ?? return None
            field.asString()
        }
    }

    public override func toString(): String {
        blob.fields() |>
            map<(Oid, () -> DerField), String> {
            it =>
            let (oid, lazyField) = it
            let field = lazyField()
            let v = field.asString()
            match {
                case oid == PrincipalOids.COUNTRY_NAME => "c=${v}"
                case oid == PrincipalOids.STATE_OR_PROVINCE_NAME => "st=${v}"
                case oid == PrincipalOids.LOCALITY_NAME => "l=${v}"
                case oid == PrincipalOids.ORGANIZATION_NAME => "o=${v}"
                case oid == PrincipalOids.ORGANIZATIONAL_UNIT_NAME => "ou=${v}"
                case oid == PrincipalOids.COMMON_NAME => "cn=${v}"
                case oid == PrincipalOids.EMAIL => "email=${v}"
                case _ => ""
            }
        } |> filter<String> {it => !it.isEmpty()} |> collectString<String>(delimiter: ",")
    }
}

public struct VerifyOption {
    // Time, default current time.
    public var time: DateTime = DateTime.now()

    // DNS, default empty.
    public var dnsName: String = ""

    // Root cert chain, default system root certs.
    public var roots: Array<X509Certificate> = X509Certificate.systemRootCerts()

    // Intermediate cert chain, default empty.
    public var intermediates: Array<X509Certificate> = Array<X509Certificate>()
}

@C
struct RawX509Cert {
    var content: CPointer<Byte> = CPointer<Byte>()
    var size: UIntNative = 0

    init(content: CPointer<Byte>, size: UIntNative) {
        this.content = content
        this.size = size
    }
}

@C
struct RawX509CertArray {
    var buffer: CPointer<RawX509Cert> = CPointer<RawX509Cert>()
    var size: UIntNative = 0

    init(buffer: CPointer<RawX509Cert>, size: UIntNative) {
        this.buffer = buffer
        this.size = size
    }
}

@C
struct X509CertInfo {
    let serialNumber: CString
    let begin: CString
    let end: CString
    let subAltName: CString
    let keyUsage: CString
    let extKeyUsage: CString

    init(
        serialNumber: CString,
        begin: CString,
        end: CString,
        subAltName: CString,
        keyUsage: CString,
        extKeyUsage: CString
    ) {
        this.serialNumber = serialNumber
        this.begin = begin
        this.end = end
        this.subAltName = subAltName
        this.keyUsage = keyUsage
        this.extKeyUsage = extKeyUsage
    }
}

// Build RawX509Cert and collect raw handles.
func getRawX509CertAndCollectHandles(data: Array<Byte>, handles: ArrayList<CPointerHandle<Byte>>) {
    let handle = unsafe { acquireArrayRawData(data) }
    handles.add(handle)
    RawX509Cert(handle.pointer, UIntNative(data.size))
}

func writeChainAndCollectHandles(
    dbs: Array<DerBlob>,
    chainPtr: CPointer<RawX509CertArray>,
    certPtr: CPointer<RawX509Cert>,
    handles: ArrayList<CPointerHandle<Byte>>
) {
    // Write certs.
    for (i in 0..dbs.size) {
        unsafe { certPtr.write(i, getRawX509CertAndCollectHandles(dbs[i].content, handles)) }
    }
    // Write chain.
    unsafe { chainPtr.write(RawX509CertArray(certPtr, UIntNative(dbs.size))) }
}

func verifyCertChain(cert: DerBlob, roots: Array<DerBlob>, intermediates: Array<DerBlob>): Int32 {
    var handles = ArrayList<CPointerHandle<Byte>>()
    // Malloc memory: 1 + roots.size + intermediate.size RawX509Certs.
    let size = 1 + roots.size + intermediates.size
    var certs = unsafe { LibC.malloc<RawX509Cert>(count: size) }
    if (certs.isNull()) {
        throw X509Exception("X509Cert verify failed: Failed to allocate memory.")
    }
    let chainCount = 2
    // Malloc memory: 2 RawX509CertArrays.
    var chains = unsafe { LibC.malloc<RawX509CertArray>(count: chainCount) }
    if (chains.isNull()) {
        unsafe { LibC.free(certs) }
        throw X509Exception("X509Cert verify failed: Failed to allocate memory.")
    }
    // Write raw data.
    unsafe {
        // Write cert.
        certs.write(getRawX509CertAndCollectHandles(cert.content, handles))
        writeChainAndCollectHandles(roots, chains, certs + 1, handles)
        writeChainAndCollectHandles(intermediates, chains + 1, certs + 1 + roots.size, handles)
    }
    // Verify by calling C interface.
    let status = unsafe { verifyX509Cert(certs, chains, chains + 1) }
    unsafe {
        // Release CPointer handlers.
        for (handle in handles) {
            releaseArrayRawData(handle)
        }
        // Free memeory.
        LibC.free(certs)
        LibC.free(chains)
    }
    status
}

@When[os != "Windows"]
func getCertsRecursively(root: Path, result: HashSet<X509Certificate>): Unit {
    if (exists(root)) {
        let condition1 = root.extensionName == "pem"
        let condition2 = root.extensionName == "crt"
        let condition3 = root.extensionName == "cer"
        if (condition1 || condition2 || condition3) {
            try {
                let pem = String.fromUtf8(File.readFrom(root))
                result.add(all: X509Certificate.decodeFromPem(pem))
            } catch (e: IllegalArgumentException) {
                result.add(X509Certificate.decodeFromDer(DerBlob(File.readFrom(root))))
            } catch (e: X509Exception) {
                throw X509Exception("${root} isn't a vaild certificate PEM file.")
            }
        }
    } else if (exists(root)) {
        // File and Directories
        Directory.walk(root) { entry =>
            getCertsRecursively(entry.path, result)
            true
        }
    }
}

@When[os == "Windows"]
func getSystemRootCerts(): Array<X509Certificate> {
    var result = HashSet<X509Certificate>()
    unsafe {
        let certStr = CJ_SystemRootCerts()
        if (!certStr.isNull()) {
            try {
                result.add(all: X509Certificate.decodeFromPem(certStr.toString()))
            } finally {
                LibC.free(certStr)
            }
        }
    }
    result.toArray()
}

@When[os != "Windows"]
func getSystemRootCerts(): Array<X509Certificate> {
    var result = HashSet<X509Certificate>()
    let rootList = 
        [
            "/etc/ssl/certs/",
            "/etc/pki/tls/certs/",
            "/system/etc/security/cacerts/",
            "/etc/ssl/ca-bundle.pem",
            "/etc/pki/tls/cacert.pem",
            "/etc/pki/ca-trust/extracted/pem/tls-ca-bundle.pem",
            "/etc/ssl/cert.pem"
        ]
    for (root in rootList) {
        getCertsRecursively(Path(root), result)
    }
    result.toArray()
}
