/*
 * Copyright (c) Huawei Technologies Co., Ltd. 2025. All rights reserved.
 * This source file is part of the Cangjie project, licensed under Apache-2.0
 * with Runtime Library Exception.
 *
 * See https://cangjie-lang.cn/pages/LICENSE for license information.
 */

package stdx.crypto.x509

import std.time.DateTime
import std.collection.{ArrayList, map}

struct DerField <: ToString {
    DerField(
        let fieldType: DerType,
        let length: Int64,
        let body: Array<Byte>
    ) {}

    func asSequence(): DerSequence {
        if (fieldType != DerType.SEQUENCE) {
            throw X509Exception("The field is not a sequence: ${fieldType}.")
        }

        DerSequence(body)
    }

    func asArrayByte(): Array<Byte> {
        let content = match {
            case fieldType == DerType.ASN_INT => body
            case _ => throw X509Exception("Unsupported field type: ${fieldType}.")
        }
        content
    }

    func asTime(): DateTime {
        let content = match {
            case fieldType == DerType.GENERALIZED_TIME || fieldType == DerType.UTC_TIME => String.fromUtf8(body)
            case _ => throw X509Exception("Unsupported field type: ${fieldType}.")
        }

        let format = match {
            case fieldType == DerType.UTC_TIME => "yyMMddHHmmssOO"
            case fieldType == DerType.GENERALIZED_TIME => "yyyyMMddHHmmssOO"
            case _ => throw X509Exception("Unsupported field type: ${fieldType}.")
        }

        if (!content.endsWith("Z")) {
            throw X509Exception("Illegal date format: ${content}, should be ${format}Z.")
        }

        let stdBuilder = StringBuilder()
        stdBuilder.append(content[..content.size - 1])
        stdBuilder.append("+00:00")
        DateTime.parse(stdBuilder.toString(), format)
    }

    func asString(): String {
        String.fromUtf8(body)
    }

    public override func toString(): String {
        "DER(type = ${fieldType}, length: ${length})"
    }

    prop blob: DerBlob {
        get() {
            var field = ArrayList<Byte>()
            field.add(all: formDerType(fieldType))
            field.add(all: formDerLength(length))
            field.add(all: body)
            DerBlob(field.toArray())
        }
    }

    // X.690 ASN.1 encoding rules
    func formDerType(derType: DerType): ArrayList<Byte> {
        var first: Byte = match (derType.derClass) {
            case Universal => 0
            case Application => 1
            case ContextSpecific => 2
            case Private => 3
        }
        var identifier = derType.typeIdentifier
        var pc = match (derType.primitive) {
            case false => UInt8(1)
            case true => UInt8(0)
        }
        first = (first << 2) | pc
        // low tag number in the range 0 to 30 (inclusive).
        if (identifier <= 30) {
            first = (first << 5) | UInt8(identifier)
            return ArrayList<Byte>.of(first)
        }
        // identifier tag number greater than 30
        first = (first << 5) | 0x1f
        var arr = ArrayList<Byte>.of(first)
        while (true) {
            var tag: Byte = UInt8(identifier) & 0x7f
            identifier = identifier >> 7
            if (identifier == 0) {
                arr.add(tag)
                break
            }
            tag = tag | 0x80
            arr.add(tag)
        }
        arr
    }

    func formDerLength(len: Int64): ArrayList<Byte> {
        var length = len
        // length is less than or equal to 127 in short form
        if (length <= 127) {
            return ArrayList<Byte>.of(UInt8(length))
        }
        // length is greater than 127 in long form
        var count: Byte = 0
        var arr = ArrayList<Byte>()
        while (true) {
            let octet: Byte = UInt8(length & 0xff)
            length = length >> 8
            arr.add(octet)
            count++
            if (length == 0) {
                break
            }
        }
        arr.add(UInt8(count | 0x80))
        arr.reverse()
        arr
    }
}

class DerSequence <: Collection<DerField> {
    private let fields: Array<(DerType, Int64)>

    DerSequence(private let body: Array<Byte>) {
        var parser = DerParser(body)
        let positions = ArrayList<(DerType, Int64)>()

        while (parser.hasRemaining) {
            let offset = parser.at
            let ty = parser.skipDerField()

            positions.add((ty, offset))
        }

        fields = positions.toArray()
    }

    public override prop size: Int64 {
        get() {
            fields.size
        }
    }

    public override func isEmpty(): Bool {
        fields.isEmpty()
    }

    public override func iterator(): Iterator<DerField> {
        fields |>
            map {
            it: (DerType, Int64) =>
            let (_, position) = it
            if (position >= body.size) {
                throw X509Exception("X509 parse failed: out of index.")
            }
            var parser = DerParser(body[position..])
            parser.parseNextDerField()
        }
    }

    operator func [](index: Int64): DerField {
        if (index >= fields.size) {
            throw X509Exception("DerSequence index out of bounds.")
        }
        let (_, position) = fields[index]
        if (position >= body.size) {
            throw X509Exception("X509 parse failed: out of index.")
        }
        var parser = DerParser(body[position..])
        parser.parseNextDerField()
    }
}
