/*
 * Copyright (c) Huawei Technologies Co., Ltd. 2025. All rights reserved.
 * This source file is part of the Cangjie project, licensed under Apache-2.0
 * with Runtime Library Exception.
 *
 * See https://cangjie-lang.cn/pages/LICENSE for license information.
 */

package stdx.crypto.x509

import std.time.DateTime

class X509Blob <: Equatable<X509Blob> & Hashable {
    let content: DerBlob
    private let certInfo: DerSequence
    private let algorithmSeq: DerSequence
    private let signatureBit: Array<Byte>
    let serialNumber: SerialNumber
    let signature: Signature
    let issuer: X500Principal
    let notBefore: DateTime
    let notAfter: DateTime
    let signatureAlgorithm: SignatureAlgorithm
    let publicKey: DerField
    let publicKeyAlgorithm: PublicKeyAlgorithm
    let subject: X500Principal

    private var versionOffset = 0

    private static const CERT_INFO_OFFSET = 0
    private static const ALGORITHM_INFO_OFFSET = 1
    private static const SIGNATURE_OFFSET = 2

    private static const SERIALNUMBER_OFFSET = 1
    private static const ISSUER_OFFSET = 3
    private static const SUBJECT_OFFSET = 5
    private static const VALIDITY_OFFSET = 4
    private static const PUBLIC_KEY_OFFSET = 6
    private static const EXTENSION_OFFSET = 7

    private static const VALID_FROM_OFFSET = 0
    private static const VALID_UNTIL_OFFSET = 1

    // Extensions
    prop dnsNames: Array<String> {
        get() {
            getX509DnsNames(content)
        }
    }

    prop emailAddresses: Array<String> {
        get() {
            getX509EmailAddresses(content)
        }
    }

    prop IPAddresses: Array<IP> {
        get() {
            getX509IpAddresses(content)
        }
    }

    prop keyUsage: KeyUsage {
        get() {
            getX509KeyUsage(content)
        }
    }

    prop extKeyUsage: ExtKeyUsage {
        get() {
            getX509ExtKeyUsage(content)
        }
    }

    init(content: Array<Byte>) {
        this(DerBlob(content))
    }

    init(content: DerBlob) {
        this.content = content
        if (content.content.size == 0) {
            throw X509Exception("X509 init failed: The content is empty.")
        }
        let wholeCert = DerSequence(content.content)[0].asSequence()

        certInfo = wholeCert[CERT_INFO_OFFSET].asSequence()
        if (certInfo[0].fieldType != DerType.VERSION_TYPE) {
            versionOffset = 1
        }

        algorithmSeq = wholeCert[ALGORITHM_INFO_OFFSET].asSequence()
        var parserIn = DerParser(algorithmSeq[0].body)
        let oidIn = parserIn.parseDerObjId()
        var parserOut = DerParser(certInfo[SIGNATURE_OFFSET - versionOffset].asSequence()[0].body)
        let oidOut = parserOut.parseDerObjId()
        if (oidIn != oidOut) {
            throw X509Exception(
                "X509Cert init failed: signatureAlgorithm must contain the same algorithm identifier as the signature field in the sequence tbsCertificate."
            )
        }

        signatureAlgorithm = parseAndCheckSignatureAlgorithm(algorithmSeq[0].body)

        checkDerType(wholeCert[SIGNATURE_OFFSET].fieldType, DerType.BIT_STREAM)
        signatureBit = wholeCert[SIGNATURE_OFFSET].body
        if (signatureBit.size < 2 || signatureBit[0] != 0) {
            throw X509Exception("Wrong signature format: bit stream is not supported.")
        }
        signature = Signature(DerBlob(signatureBit[1..]))

        serialNumber = parseAndCheckSerialNumber(certInfo[SERIALNUMBER_OFFSET - versionOffset])
        checkDerType(certInfo[ISSUER_OFFSET - versionOffset].fieldType, DerType.SEQUENCE)
        issuer = X500Principal(certInfo[ISSUER_OFFSET - versionOffset])

        notBefore = certInfo[VALIDITY_OFFSET - versionOffset].asSequence()[VALID_FROM_OFFSET].asTime()
        notAfter = certInfo[VALIDITY_OFFSET - versionOffset].asSequence()[VALID_UNTIL_OFFSET].asTime()

        publicKey = certInfo[PUBLIC_KEY_OFFSET - versionOffset]
        publicKeyAlgorithm = parseAndCheckPublicKeyAlgorithm(publicKey)

        checkDerType(certInfo[SUBJECT_OFFSET - versionOffset].fieldType, DerType.SEQUENCE)
        subject = X500Principal(certInfo[SUBJECT_OFFSET - versionOffset])

        if (certInfo.size == 8) {
            checkDerType(certInfo[EXTENSION_OFFSET - versionOffset].fieldType, DerType.EXTENSION_OPTION)
        }
    }

    public override operator func ==(other: X509Blob): Bool {
        content == other.content
    }

    public override operator func !=(other: X509Blob): Bool {
        content != other.content
    }

    public override func hashCode(): Int64 {
        content.hashCode()
    }
}

func checkDerType(inDerType: DerType, defaultDerType: DerType) {
    if (inDerType != defaultDerType) {
        throw X509Exception("X509Cert init failed: Unsupported field type: ${inDerType}.")
    }
}

func parseAndCheckSerialNumber(serialInfo: DerField): SerialNumber {
    var arrayBody = serialInfo.asArrayByte()
    // serialNumber is a positive number with a sign bit 0
    // if serialNumber >= 128, we should delete the sign bit
    if (arrayBody.size > 1 && arrayBody[0] == 0 && arrayBody[1] >= 128) {
        return SerialNumber(arrayBody[1..])
    }
    SerialNumber(arrayBody)
}

func parseAndCheckPublicKeyAlgorithm(publicKey: DerField): PublicKeyAlgorithm {
    var algorithmIdentifierSeq = publicKey.asSequence()[0].asSequence()
    var parser = DerParser(algorithmIdentifierSeq[0].body)
    let oid = parser.parseDerObjId()
    let res = match {
        case oid == PrincipalOids.RSA => PublicKeyAlgorithm.RSA
        case oid == PrincipalOids.DSA => PublicKeyAlgorithm.DSA
        case oid == PrincipalOids.ECDSA => PublicKeyAlgorithm.ECDSA
        case _ => PublicKeyAlgorithm.UnknownPublicKeyAlgorithm
    }
    res
}

func parseAndCheckSignatureAlgorithm(body: Array<Byte>): SignatureAlgorithm {
    var parser = DerParser(body)
    let oid = parser.parseDerObjId()
    let res = match {
        case oid == PrincipalOids.MD2WithRSA => SignatureAlgorithm.MD2WithRSA
        case oid == PrincipalOids.MD5WithRSA => SignatureAlgorithm.MD5WithRSA
        case oid == PrincipalOids.SHA1WithRSA => SignatureAlgorithm.SHA1WithRSA
        case oid == PrincipalOids.SHA256WithRSA => SignatureAlgorithm.SHA256WithRSA
        case oid == PrincipalOids.SHA384WithRSA => SignatureAlgorithm.SHA384WithRSA
        case oid == PrincipalOids.SHA512WithRSA => SignatureAlgorithm.SHA512WithRSA
        case oid == PrincipalOids.DSAWithSHA1 => SignatureAlgorithm.DSAWithSHA1
        case oid == PrincipalOids.DSAWithSHA256 => SignatureAlgorithm.DSAWithSHA256
        case oid == PrincipalOids.ECDSAWithSHA1 => SignatureAlgorithm.ECDSAWithSHA1
        case oid == PrincipalOids.ECDSAWithSHA256 => SignatureAlgorithm.ECDSAWithSHA256
        case oid == PrincipalOids.ECDSAWithSHA384 => SignatureAlgorithm.ECDSAWithSHA384
        case oid == PrincipalOids.ECDSAWithSHA512 => SignatureAlgorithm.ECDSAWithSHA512
        case _ => SignatureAlgorithm.UnknownSignatureAlgorithm
    }
    res
}

/**
 * Store the Array<Byte> result from C side.
 */
@C
struct ByteResult {
    var buffer: CPointer<Byte> = CPointer()
    var size: UIntNative = 0
}

/**
 * Store the Array<Array<Byte>> result from C side.
 */
@C
struct ByteArrayResult {
    var buffer: CPointer<ByteResult> = CPointer()
    var size: UIntNative = 0
}

/**
 * Store the Array<CString> result from C side.
 */
@C
struct StringArrayResult {
    var buffer: CPointer<CString> = CPointer()
    var size: UIntNative = 0
}

/**
 * Store the Array<UInt64> result from C side.
 */
@C
struct UInt16Result {
    var buffer: CPointer<UInt16> = CPointer()
    var size: UIntNative = 0
}

/**
 * Free the memory of temporary result from C side.
 */
func freeX509Result(data: CPointer<StringArrayResult>) {
    if (data.isNull()) {
        throw X509Exception("Null pointer check failed.")
    }

    let result: StringArrayResult = unsafe { data.read() }
    let size = Int64(result.size)
    if (size > 0) {
        let buffer: CPointer<CString> = result.buffer
        for (i in 0..size) {
            unsafe { LibC.free(buffer.read(i)) }
        }
        unsafe { LibC.free(buffer) }
    }
    unsafe { LibC.free(data) }
}

func freeX509Result(data: CPointer<ByteArrayResult>) {
    if (data.isNull()) {
        throw X509Exception("Null pointer check failed.")
    }

    let result: ByteArrayResult = unsafe { data.read() }
    let size = Int64(result.size)
    if (size <= 0) {
        unsafe { LibC.free(data) }
        return
    }

    let buffer: CPointer<ByteResult> = result.buffer
    for (i in 0..size) {
        let byteRes: ByteResult = unsafe { buffer.read(i) }
        if (byteRes.size > 0) {
            unsafe { LibC.free(byteRes.buffer) }
        }
    }
    unsafe { LibC.free(buffer) }
    unsafe { LibC.free(data) }
}

func freeX509Result(data: CPointer<UInt16Result>) {
    if (data.isNull()) {
        throw X509Exception("Null pointer check failed.")
    }

    let result: UInt16Result = unsafe { data.read() }
    let size = Int64(result.size)
    if (size > 0) {
        unsafe { LibC.free(result.buffer) }
    }
    unsafe { LibC.free(data) }
}

/**
 * Clone the result from C side and free memory.
 */
func cloneX509Result(data: CPointer<StringArrayResult>): Array<String> {
    if (data.isNull()) {
        throw X509Exception("Null pointer check failed.")
    }

    let result: StringArrayResult = unsafe { data.read() }
    let size = Int64(result.size)
    if (size <= 0) {
        freeX509Result(data)
        return Array<String>()
    }
    try {
        let buffer = result.buffer
        if (buffer.isNull()) {
            throw X509Exception("Null pointer check failed.")
        }
        return Array<String>(size) {i => bufferToString(buffer, i)}
    } finally {
        freeX509Result(data)
    }
}

private func bufferToString(buffer: CPointer<CString>, i: Int64): String {
    return unsafe {
        if (buffer.read(i).isNull()) {
            ""
        } else {
            buffer.read(i).toString()
        }
    }
}

/**
 * Clone the result from C side and free memory.
 */
func cloneX509Result(data: CPointer<ByteArrayResult>): Array<Array<Byte>> {
    if (data.isNull()) {
        throw X509Exception("Null pointer check failed.")
    }

    let result: ByteArrayResult = unsafe { data.read() }
    let size = Int64(result.size)
    let res = if (size > 0) {
        let buffer = result.buffer
        Array<Array<Byte>>(size) {
            i =>
            let byteRes = unsafe { buffer.read(i) }
            let byteBuf = byteRes.buffer
            Array<Byte>(Int64(byteRes.size)) {j => unsafe { byteBuf.read(j) }}
        }
    } else {
        Array<Array<Byte>>()
    }
    freeX509Result(data)
    res
}

/**
 * Clone the result from C side and free memory.
 */
func cloneX509Result(data: CPointer<UInt16Result>): Array<UInt16> {
    if (data.isNull()) {
        throw X509Exception("Null pointer check failed.")
    }

    let result: UInt16Result = unsafe { data.read() }
    let size = Int64(result.size)
    let res = if (size > 0) {
        let buffer = result.buffer
        Array<UInt16>(size, {i => unsafe { buffer.read(i) }})
    } else {
        Array<UInt16>()
    }
    freeX509Result(data)
    res
}

/**
 * Get the DNS names by calling C interface.
 */
func getX509DnsNames(content: DerBlob): Array<String> {
    let result = x509MallocOrThrow<StringArrayResult>()
    runOnRawPtr(content.content) {
        rawPtr: CPointer<Byte>, size: UIntNative => getX509DnsNames(rawPtr, size, result)
    }
    cloneX509Result(result)
}

/**
 * Get the Email addresses by calling C interface.
 */
func getX509EmailAddresses(content: DerBlob): Array<String> {
    let result = x509MallocOrThrow<StringArrayResult>()
    runOnRawPtr(content.content) {
        rawPtr: CPointer<Byte>, size: UIntNative => getX509EmailAddresses(rawPtr, size, result)
    }
    cloneX509Result(result)
}

/**
 * Get the IP addresses by calling C interface.
 */
func getX509IpAddresses(content: DerBlob): Array<IP> {
    let result = x509MallocOrThrow<ByteArrayResult>()
    runOnRawPtr(content.content) {
        rawPtr: CPointer<Byte>, size: UIntNative => getX509IpAddresses(rawPtr, size, result)
    }
    cloneX509Result(result)
}

/**
 * The key usage extension in X509.
 */
public struct KeyUsage <: ToString {
    var keys: UInt16 = 0

    public static let DigitalSignature: UInt16 = 0x0080
    public static let NonRepudiation: UInt16 = 0x0040
    public static let KeyEncipherment: UInt16 = 0x0020
    public static let DataEncipherment: UInt16 = 0x0010
    public static let KeyAgreement: UInt16 = 0x0008
    public static let CertSign: UInt16 = 0x0004
    public static let CRLSign: UInt16 = 0x0002
    public static let EncipherOnly: UInt16 = 0x0001
    public static let DecipherOnly: UInt16 = 0x0100
    static let keyStrings: Array<String> = [
        "EncipherOnly",
        "CRLSign",
        "CertSign",
        "KeyAgreement",
        "DataEncipherment",
        "KeyEncipherment",
        "NonRepudiation",
        "DigitalSignature",
        "DecipherOnly"
    ]

    public init(keys: UInt16) {
        this.keys = keys
    }

    public override func toString(): String {
        var res: String = ""
        var cnt: Int64 = 0
        let VALID_KEY_NUM = 9
        for (i in 0..VALID_KEY_NUM) {
            if ((keys & (1 << i)) != 0) {
                if (cnt > 0) {
                    res += ", "
                }
                cnt++
                res += keyStrings[i]
            }
        }
        res
    }
}

/**
 * The ext key usage extension in X509.
 */
public struct ExtKeyUsage <: ToString {
    var keys: Array<UInt16>

    public static let AnyKey: UInt16 = 0
    public static let ServerAuth: UInt16 = 1
    public static let ClientAuth: UInt16 = 2
    public static let EmailProtection: UInt16 = 3
    public static let CodeSigning: UInt16 = 4
    public static let OCSPSigning: UInt16 = 5
    public static let TimeStamping: UInt16 = 6

    static let keyStrings: Array<String> = [
        "AnyKey",
        "ServerAuth",
        "ClientAuth",
        "EmailProtection",
        "CodeSigning",
        "OCSPSigning",
        "TimeStamping"
    ]

    public init(keys: Array<UInt16>) {
        for (i in 0..keys.size) {
            keys[i] = if (keys[i] > TimeStamping) {
                AnyKey
            } else {
                keys[i]
            }
        }
        this.keys = keys
    }

    public override func toString(): String {
        var res: String = ""
        var cnt: Int64 = 0
        for (key in keys) {
            if (cnt > 0) {
                res += ", "
            }
            cnt++
            res += keyStrings[Int64(key)]
        }
        res
    }
}

/**
 * Get the key usage by calling C interface.
 */
func getX509KeyUsage(content: DerBlob): KeyUsage {
    let res: UInt16 = runOnRawPtr(content.content) {
        rawPtr: CPointer<Byte>, size: UIntNative => getX509KeyUsage(rawPtr, size)
    }
    KeyUsage(res)
}

/**
 * Get the ext key usage by calling C interface.
 */
func getX509ExtKeyUsage(content: DerBlob): ExtKeyUsage {
    let result = x509MallocOrThrow<UInt16Result>()
    runOnRawPtr(content.content) {
        rawPtr: CPointer<Byte>, size: UIntNative => getX509ExtKeyUsage(rawPtr, size, result)
    }
    ExtKeyUsage(cloneX509Result(result))
}
