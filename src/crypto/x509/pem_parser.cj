/*
 * Copyright (c) Huawei Technologies Co., Ltd. 2025. All rights reserved.
 * This source file is part of the Cangjie project, licensed under Apache-2.0
 * with Runtime Library Exception.
 *
 * See https://cangjie-lang.cn/pages/LICENSE for license information.
 */

package stdx.crypto.x509

import std.io.ByteBuffer
import stdx.encoding.base64.fromBase64String

const PEM_BEGIN_PREFIX = "-----BEGIN "
const PEM_END_PREFIX = "-----END "
const PEM_SUFFIX = "-----"
let OPEN_ARRAY = PEM_BEGIN_PREFIX.toArray()
let CLOSE_ARRAY = PEM_END_PREFIX.toArray()
let END_ARRAY = PEM_SUFFIX.toArray()

/**
 * LAX parser for RFC7468 and RFC1421
 */
func parsePem(content: Array<Byte>): Array<PemEntry> {
    var current = 0
    let result = ArrayBuilder<PemEntry>()

    if (content.size == 0) {
        throw X509Exception("X509 parse pem failed: Pem is empty.")
    }

    while (current < content.size) {
        let (label, preebEnd) = parsePreeb(current, content) ?? break
        current = preebEnd

        let (bodyEnd, afterEnd) = searchEnd(current, content, label)
        checkIndex(content, current, bodyEnd)
        let headers: Array<(String, String)> = if (probeForHeader(content[current..bodyEnd])) {
            let (end, res) = parseHeaders(current, content)
            current = end
            res
        } else {
            []
        }
        checkIndex(content, current, bodyEnd)
        let body = String.fromUtf8(trimInnerSpaces(content[current..bodyEnd]))
        let bodyBytes = fromBase64String(body) ?? throw X509Exception(
            "X509 parse pem failed: Failed to parse base64 encoded PEM body: ${body}.")

        current = afterEnd
        result.append(PemEntry(label, headers, DerBlob(bodyBytes)))
    }

    if (result.isEmpty()) {
        throw X509Exception("X509 parse pem failed: Failed to parse PEM.")
    }
    return result.toArray()
}

func checkIndex(content: Array<Byte>, begin: Int64, end: Int64) {
    if (begin >= content.size || end > content.size || begin > end) {
        throw X509Exception("X509 parse derfield failed: Failed to parse PEM.")
    }
}

func parsePreeb(start: Int64, content: Array<Byte>): ?(String, Int64) {
    let startIndex = indexOf(content, start, OPEN_ARRAY) ?? return None
    let labelStart = startIndex + OPEN_ARRAY.size
    let endIndex = indexOf(content, labelStart, END_ARRAY) ?? return None
    var afterIndex = endIndex + END_ARRAY.size
    afterIndex = skipSpaces(afterIndex, content)
    checkIndex(content, labelStart, endIndex)
    let label = String.fromUtf8(content[labelStart..endIndex]).trimAscii()
    return (label, afterIndex)
}

func searchEnd(start: Int64, content: Array<Byte>, label: String): (Int64, Int64) {
    let it = concat3(CLOSE_ARRAY, label.toArray(), END_ARRAY)
    let index = indexOf(content, start, it) ?? throw X509Exception(
        "X509 parse pem failed: Failed to find PEM entry end, ${String.fromUtf8(it)}.")
    return (index, index + it.size)
}

func probeForHeader(content: Array<Byte>): Bool {
    for (index in 0..content.size) {
        let v = content[index]
        if (!isSpace(v) && !isBase64(v)) {
            return true // we assume any non-space and non-base64 characters represents header
        }
    }

    return false
}

func parseHeaders(start: Int64, content: Array<Byte>): (Int64, Array<(String, String)>) {
    let builder = ArrayBuilder<(String, String)>(2)

    var index = start
    var tag = true
    while (index < content.size) {
        (index, tag) = parseHeader(index, content, builder)
        if (!tag) {
            break
        }
    }

    return (index, builder.toArray())
}

func parseHeader(index: Int64, content: Array<Byte>, builder: ArrayBuilder<(String, String)>): (Int64, Bool) {
    var tempIndex = index
    let start = index
    var delimiterIndex = -1
    var lineEnd = content.size

    while (tempIndex < content.size) {
        match (content[tempIndex]) {
            case ':' => delimiterIndex = tempIndex
            case '\n' =>
                lineEnd = if (tempIndex > 0 && content[tempIndex - 1] == b'\r') {
                    tempIndex - 1
                } else {
                    tempIndex
                }
                tempIndex++
                break
            case _ => ()
        }
        tempIndex++
    }

    if (lineEnd == start) {
        return (tempIndex, false)
    }
    if (delimiterIndex == -1) {
        let line = String.fromUtf8(content[start..lineEnd])
        if (line.isAsciiBlank()) {
            return (tempIndex, false)
        }
        throw X509Exception("X509 parse pem failed: Unexpected line in PEM header, line ${line.trimAscii()}.")
    }
    let headerName = String.fromUtf8(content[start..delimiterIndex]).trimAsciiEnd()
    let headerValue = String.fromUtf8(content[delimiterIndex + 1..lineEnd]).trimAsciiStart()
    builder.append((headerName, headerValue))
    return (tempIndex, true)
}

func skipSpaces(start: Int64, content: Array<Byte>): Int64 {
    for (index in start..content.size) {
        let v = content[index]
        if (!isSpace(v)) {
            return index
        }
    }

    return content.size
}

func isSpace(v: Byte): Bool {
    v == b' ' || v == b'\t' || v == b'\r' || v == b'\n'
}

func isBase64(v: Byte): Bool {
    v.isAsciiNumberOrLetter() || v == b'=' || v == b'+' || v == b'/'
}

func indexOf(self: Array<Byte>, start: Int64, other: Array<Byte>): ?Int64 {
    let first = other[0]
    for (index in start..(self.size - other.size + 1)) {
        if (self[index] == first && self[index..index + other.size] == other) {
            return index
        }
    }

    return None
}

func concat3(a: Array<Byte>, b: Array<Byte>, c: Array<Byte>): Array<Byte> {
    let result = Array<Byte>(a.size + b.size + c.size, repeat: 0)
    a.copyTo(result, 0, 0, a.size)
    b.copyTo(result, 0, a.size, b.size)
    c.copyTo(result, 0, a.size + b.size, c.size)
    return result
}

func trimInnerSpaces(content: Array<Byte>): Array<Byte> {
    for (index in 0..content.size) {
        if (isSpace(content[index])) {
            return trimInnerSpacesImpl(content, startIndex: index)
        }
    }

    return content
}

func trimInnerSpacesImpl(content: Array<Byte>, startIndex!: Int64): Array<Byte> {
    let builder = ByteBuffer(content.size)
    builder.write(content[..startIndex])

    for (index in startIndex + 1..content.size) {
        let v = content[index]
        if (!isSpace(v)) {
            builder.write(v)
        }
    }

    return builder.bytes()
}
