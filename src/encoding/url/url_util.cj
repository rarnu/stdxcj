/*
 * Copyright (c) Huawei Technologies Co., Ltd. 2025. All rights reserved.
 * This source file is part of the Cangjie project, licensed under Apache-2.0
 * with Runtime Library Exception.
 *
 * See https://cangjie-lang.cn/pages/LICENSE for license information.
 */

/**
 * @file The file declares the top level function.
 */
package stdx.encoding.url

import std.collection.*

let HOST_ESCAPE = strToCharSet("\u{0000}")
let ZONE_ESCAPE = strToCharSet("\u{0001}")
let CAN_ASCII = strToCharSet("\u{0002}")
let HEX_BYTE_ARR = "0123456789ABCDEF".toArray()

/*
 * a-z
 */
let LOW_ALPHA = highAsciiToBitSet(r'a', r'z')

/*
 * A-Z
 */
let UP_ALPHA = highAsciiToBitSet(r'A', r'Z')

/*
 * 0-9
 */
let DIGIT = (lowAsciiToBitSet(r'0', r'9'), 0)

/*
 * a-z | A-Z
 */
let ALPHA = (0, LOW_ALPHA | UP_ALPHA)

/*
 * unreserved = ALPHA / DIGIT / "-" / "." / "_" / "~"
 */
let UNRESERVED = mergeCharSet([ALPHA, DIGIT, strToCharSet("-._~")])

/*
 * sub-delims = "!" / "$" / "&" / "'" / "(" / ")" / "*" / "+" / "," / ";" / "="
 */
let SUB_DELIMS = strToCharSet("!$&'()*+,;=")

/*
 * pct-encoded
 */
let ENCODED = strToCharSet("%")

/*
 * userinfo = *( unreserved / pct-encoded / sub-delims / ":" )
 */
let USERINFO = mergeCharSet([UNRESERVED, SUB_DELIMS, ENCODED, strToCharSet(":")])
let ENCODE_USERINFO = mergeCharSet([UNRESERVED, SUB_DELIMS, ENCODED])

/*
 * scheme = ALPHA *( ALPHA / DIGIT / "+" / "-" / "." )
 */
let SCHEME = mergeCharSet([ALPHA, DIGIT, strToCharSet("+-.")])

/*
 * IPv4address = dec-octet "." dec-octet "." dec-octet "." dec-octet
 * dec-octet   = DIGIT                 ; 0-9
 *             / %x31-39 DIGIT         ; 10-99
 *             / "1" 2DIGIT            ; 100-199
 *             / "2" %x30-34 DIGIT     ; 200-249
 *             / "25" %x30-35          ; 250-255
 */
let IPV4 = mergeCharSet([DIGIT, strToCharSet(".:")])

/*
 * ZoneID = 1*( unreserved / pct-encoded )
 */
let ZONE = mergeCharSet([UNRESERVED, ENCODED, ZONE_ESCAPE])

/*
 * IPv6addrz = IPv6address "%25" Zone
 * IP-literal = "[" ( IPv6address / IPvFuture) "]"
 * IPv6address = 6( h16 ":" ) ls32 ...
 * ls32 = ( h16 ":" h16 ) / IPv4address; least-significant 32 bits of address
 * h16 = 1*4HEXDIG; 16 bits of address represented in hexadecimal
 */
let IPV6 = mergeCharSet([IPV4, strToCharSet("[]ABCDEFabcdef")])

/*
 * reg-name    = *( unreserved / pct-encoded / sub-delims )
 */
let REG_NAME = mergeCharSet([UNRESERVED, SUB_DELIMS, ENCODED, strToCharSet(":"), HOST_ESCAPE, CAN_ASCII])

/*
 * host = IP-literal / IPv4address / reg-name
 */
let HOST = mergeCharSet([IPV4, IPV6, REG_NAME, ZONE])

/*
 * pchar = unreserved / pct-encoded / sub-delims / ":" / "@"
 */
let PCHAR = mergeCharSet([UNRESERVED, SUB_DELIMS, ENCODED, strToCharSet(":@")])
let PATH = mergeCharSet([PCHAR, strToCharSet("/"), CAN_ASCII])

/*
 * query = *( pchar / "/" / "?" )
 */
let QUERY = mergeCharSet([PATH, strToCharSet("/?")])

/*
 * fragment    = *( pchar / "/" / "?" )
 */
let FRAGMENT = mergeCharSet([PCHAR, strToCharSet("/?")])

func strToCharSet(s: String): (Int64, Int64) {
    return (lowAsciiToBitSet(s), highAsciiToBitSet(s))
}

func mergeCharSet(tupleList: Array<(Int64, Int64)>): (Int64, Int64) {
    var t = (0, 0)
    for (i in tupleList) {
        t = (t[0] | i[0], t[1] | i[1])
    }
    return t
}

func lowAsciiToBitSet(s: String): Int64 {
    var mask = 0
    for (i in s) {
        if (i < b'@') {
            mask |= (1 << Int64(i))
        }
    }
    return mask
}

func lowAsciiToBitSet(start: Rune, end: Rune): Int64 {
    var mask = 0
    for (i in UInt32(start)..=UInt32(end)) {
        mask |= 1 << i
    }
    return mask
}

func highAsciiToBitSet(s: String): Int64 {
    var mask = 0
    for (i in s) {
        if (i >= b'@' && i <= 127) {
            mask |= (1 << (Int64(i) - 64))
        }
    }
    return mask
}

func highAsciiToBitSet(start: Rune, end: Rune): Int64 {
    var mask = 0
    for (i in UInt32(start) - 64..UInt32(end) - 63) {
        mask |= 1 << i
    }
    return mask
}

func isByteInSet(c: Byte, maskTuple: (Int64, Int64)): Bool {
    /* 0 doesn't have a slot in the mask. So it never isCharInSet. */
    if (c == 0) {
        return false
    }
    if (c < 64) {
        return ((1 << c) & maskTuple[0]) != 0
    }
    if (c <= 127) {
        return ((1 << (c - 64)) & maskTuple[1]) != 0
    }
    return false
}

func encode(component: String, componentMaskTuple: (Int64, Int64), isQuery!: Bool = false): String {
    if (component.size <= 0) {
        return String.empty
    }
    let encoded = StringBuilder(component.size * 3)
    encode(component, componentMaskTuple, encoded, isQuery: isQuery)
    return encoded.toString()
}

func encode(component: String, componentMaskTuple: (Int64, Int64), encoded: StringBuilder, isQuery!: Bool = false): Unit {
    var noEscape = true
    var byte: Byte
    for (i in 0..component.size) {
        byte = component[i]
        if (byte == b' ' && isQuery) {
            noEscape = false
            break
        }
        if (byte == b'%' || byte > 128 || !isByteInSet(byte, componentMaskTuple)) {
            noEscape = false
            break
        }
    }
    if (noEscape) {
        encoded.append(component)
        return
    }
    var buf = Array<Byte>(component.size * 3, repeat: b'%')
    var idx = 0
    for (i in 0..component.size) {
        byte = component[i]
        if (byte == b' ' && isQuery) {
            buf[idx] = b'+'
            idx++
        } else if (byte == b'%' || byte > 128 || !isByteInSet(byte, componentMaskTuple)) {
            buf[idx + 1] = HEX_BYTE_ARR[Int64(byte >> 4)]
            buf[idx + 2] = HEX_BYTE_ARR[Int64(byte & 0xF)]
            idx += 3
        } else {
            buf[idx] = byte
            idx++
        }
    }
    unsafe { encoded.appendFromUtf8Unchecked(buf[..idx]) }
}

/**
 * converting each 3 char encoded substring of the form "%AB" into the
 * hex-decoded byte 0xAB. It also converts r'+' into r' ' (space).
 *
 * @param The query component
 *
 * @return The decoded query component
 *
 * @throws UrlSyntaxException if get an invalid URL escape
 * @throws IllegalArgumentException if there is an invalid utf8 leading code in 'str'
 */
func decode(str: String, isQuery!: Bool = false): String {
    var it = str.runes()
    var s = StringBuilder()
    var buffer = ArrayList<UInt8>()
    var escape = false
    var i = 0
    while (true) {
        var c = match (it.next()) {
            case None => break
            case Some(next) => next
        }
        match (c) {
            case r'%' =>
                if (str.size < i + 2) {
                    throw UrlSyntaxException(str, "Invalid URL escape.")
                }
                let c1 = it.next() ?? r' '
                let c2 = it.next() ?? r' '
                if (!c1.isAsciiHex() || !c2.isAsciiHex()) {
                    throw UrlSyntaxException(str, "Invalid URL escape.")
                }
                if (!escape) {
                    buffer = ArrayList<UInt8>()
                }
                escape = true
                buffer.add(hexToDec(c1) << 4 | hexToDec(c2))
            /* converts r'+' into r' ' (space). */
            case r'+' where isQuery =>
                if (escape) {
                    s.appendFromUtf8(buffer.toArray())
                }
                s.append(r' ')
                escape = false
            case _ =>
                if (escape) {
                    s.appendFromUtf8(buffer.toArray())
                }
                s.append(c)
                escape = false
        }
        i++
    }
    if (escape) {
        s.appendFromUtf8(buffer.toArray())
    }
    return s.toString()
}

/**
 * Hexadecimal characters are converted into decimal numbers of the UInt8 type.
 */
func hexToDec(c: Rune): UInt8 {
    match {
        case r'0' <= c && c <= r'9' => UInt8(UInt32(c) - UInt32(r'0'))
        case r'a' <= c && c <= r'f' => UInt8(UInt32(c) - UInt32(r'a') + UInt32(10))
        case r'A' <= c && c <= r'F' => UInt8(UInt32(c) - UInt32(r'A') + UInt32(10))
        case _ => UInt8(0)
    }
}

func hexToDec(b: Byte): UInt8 {
    match {
        case b'0' <= b && b <= b'9' => b - b'0'
        case b'a' <= b && b <= b'f' => b - b'a' + 10
        case b'A' <= b && b <= b'F' => b - b'A' + 10
        case _ => UInt8(0)
    }
}

extend<T> ArrayList<T> {
    func toArrayWithoutCopy(): Array<T> {
        unsafe { this.getRawArray()[..size] }
    }
}

func isEndSlashNeeded(paths: Iterator<String>, variablePaths: ArrayList<String>): Bool {
    var retValue = false
    for (i in paths) {
        match (i) {
            case "" => ()
            case "." => retValue = true // if the path ends with r'.' add r'/' at the end of the path.
            case ".." =>
                if (!variablePaths.isEmpty()) {
                    variablePaths.remove(at: variablePaths.size - 1)
                }
                // if the path ends with ".." add / at the end of the path.
                retValue = true
            case _ =>
                variablePaths.add(i)
                // the end is not .. or . Do not need to forcibly add a slash (/).
                retValue = false
        }
    }
    return retValue
}

const SOCK_ADDR_IPV4_LEN = 4
const SOCK_ADDR_IPV6_LEN = 16

/**
 * returned value: ip, err
 */
func parseIPv4(address: String): (Array<UInt8>, Bool) {
    if (address.size < 7 || address.size > 15) {
        return (Array<Byte>(), true)
    }

    var current = 0

    let ip = Array<UInt8>(SOCK_ADDR_IPV4_LEN, repeat: 0)
    for (index in 0..SOCK_ADDR_IPV4_LEN) {
        (ip[index], current) = parseIpv4Number(address, current) ?? return (Array(), true)
    }
    if (current != address.size) {
        return (Array(), true)
    }
    return (ip, false)
}

func parseIpv4Number(address: String, current: Int64): ?(UInt8, Int64) {
    var number = 0
    var index = current

    // here we have a custom UInt8.tryParse implementation
    // the reason why we have it here is that the default implementation
    // does String.replace("_", "") and String.charAt that is usually acceptable
    // but under stress tests these functions slowdown parsing a lot.
    // the first replacement is not needed actually as IP address should never allow
    // underscores and the second function introduces O(n^2) that is even on small strings
    // may cause slowdown under high load
    while (index < address.size) {
        let b = address[index]
        if (b.isAsciiNumber()) {
            number = number * 10 + Int64(b - b'0')
            if (number > 0xff) {
                return None
            }
            index++
        } else if (b == b'.') {
            break
        } else {
            return None
        }
    }

    // we either got dot or end of string
    if (index == current) {
        return None
    } // dot without number or premature end
    if (index == address.size - 1) {
        return None
    } // not eof but trailing dot
    if (index < address.size) {
        index++ // just dot
    }

    return (UInt8(number), index)
}

@OverflowWrapping
func parseIPv6(src: String): (Array<UInt8>, String, Bool) {
    var offset = 0
    var zone = ""
    var s = src
    match (src.indexOf(b'%')) {
        case Some(v) =>
            zone = s[v + 1..]
            s = s[..v]
            if (zone.size == 0) {
                throw UrlSyntaxException(s, "zone must be a non-empty string")
            }
        case _ => ()
    }

    if (s[0] == b':' && s[1] != b':') {
        throw UrlSyntaxException(src, "each colon-separated field must have at least one digit", s[offset..])
    }

    var ellipsis: ?Int64 = None

    if (s.size >= 2 && s[0] == b':') {
        if (s[1] == b':') {
            ellipsis = 0
            offset += 2
            if (s[offset..].size == 0) {
                return (Array<UInt8>(SOCK_ADDR_IPV6_LEN, repeat: 0), zone, false)
            }
        } else {
            throw UrlSyntaxException(src, "unexpected character, want colon", s[1..])
        }
    }
    let (ok, o, i, e, ip) = innerParseIPv6(s, src, offset, ellipsis)
    if (!ok) {
        return (Array(), "", true)
    }
    offset = o
    ellipsis = e
    if (offset < s.size) {
        throw UrlSyntaxException(src, "address contain garbage", s[offset..])
    }
    if (i == 16 && ellipsis.isSome()) {
        throw UrlSyntaxException(src, "does not contain a valid network address", s[offset..])
    }
    if (i < 16) {
        if (let Some(ellipsis_index) <- ellipsis) {
            let nb_zeros = 16 - i
            for (index in i - 1..=ellipsis_index : -1) {
                ip[index + nb_zeros] = ip[index]
            }
            for (index in ellipsis_index + nb_zeros - 1..=ellipsis_index : -1) {
                ip[index] = 0
            }
        } else {
            throw UrlSyntaxException(src, "address string too short", s)
        }
    }
    return (ip, zone, false)
}

@OverflowWrapping
func innerParseIPv6(s: String, src: String, begin: Int64, e: ?Int64) {
    var ip = Array<UInt8>(SOCK_ADDR_IPV6_LEN, repeat: 0)
    var offset = begin
    var i = 0
    var ellipsis = e
    while (offset < s.size) {
        let (bytes_read, hextet) = readHextet(s[offset..])
        if (hextet > UInt32(UInt16.Max)) {
            throw UrlSyntaxException(src, "IPv6 field has value >=2^16", s[offset..])
        }
        if (bytes_read == 0) {
            if (s[offset] != b':') {
                throw UrlSyntaxException(src, "each colon-separated field must have at least one digit", s[offset..])
            }
            if (ellipsis.isSome()) {
                throw UrlSyntaxException(src, "an IPv6 address can only have one ellipsis", s[offset..])
            }
            ellipsis = i
            offset += 1
            continue
        }
        ip[i] = UInt8(hextet >> 8)
        ip[i + 1] = UInt8(hextet)

        offset += bytes_read
        i += 2
        if (i == 16 || offset == s.size) {
            break
        }
        match (s[offset]) {
            case ':' => offset += 1
            case '.' =>
                if (ellipsis.isNone() && i != 12) {
                    throw UrlSyntaxException(src, "embedded IPv4 address must replace the final 2 fields of the address", s[offset..])
                }
                if (i + 4 > 16) {
                    throw UrlSyntaxException(src, "too many hex fields to fit an embedded IPv4 at the end of the address", s[offset..])
                }
                var (arr, err) = parseIPv4(s[(offset - bytes_read)..])
                if (err) {
                    return (false, offset, i, ellipsis, ip)
                }
                arr.copyTo(ip, 0, i - 2, arr.size)
                i += 2
                offset += s.size - offset + bytes_read
                break
            case _ => throw UrlSyntaxException(src, "contain invalid character", s[offset..])
        }
    }
    return (true, offset, i, ellipsis, ip)
}

func readHextet(buffer: String): (Int64, UInt32) {
    var count = 0
    let digits = Array<Byte>(8, repeat: 0)
    for (b in buffer) {
        if (b.isAsciiHex()) {
            digits[count] = hexToDec(b)
            count++
        } else {
            break
        }
    }
    if (count == 0) {
        return (0, 0)
    }

    var shift = (count - 1) * 4
    var res = 0u32
    for (digit in digits) {
        res += UInt32(digit) << shift
        if (shift >= 4) {
            shift -= 4
        } else {
            break
        }
    }
    return (count, res)
}

extend String {
    func ensureAsciiLower(): String {
        for (i in 0..this.size where this[i] < b'a' || this[i] > b'z') {
            return this.toAsciiLower()
        }
        return this
    }
}