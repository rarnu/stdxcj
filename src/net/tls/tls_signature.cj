/*
 * Copyright (c) Huawei Technologies Co., Ltd. 2025. All rights reserved.
 * This source file is part of the Cangjie project, licensed under Apache-2.0
 * with Runtime Library Exception.
 *
 * See https://cangjie-lang.cn/pages/LICENSE for license information.
 */

package stdx.net.tls

import stdx.crypto.digest.*

/**
 * Signature algorithm to be used to verify authenticity.
 * See RFC5246 7.4.1.4.1.
 */
public enum SignatureType <: ToString & Equatable<SignatureType> {
    | ECDSA
    | DSA
    | RSA

    public func toString(): String {
        match (this) {
            case ECDSA => "ECDSA"
            case DSA => "DSA"
            case RSA => "RSA"
        }
    }

    public operator func ==(other: SignatureType): Bool {
        match ((this, other)) {
            case (ECDSA, ECDSA) => true
            case (DSA, DSA) => true
            case (RSA, RSA) => true
            case _ => false
        }
    }

    public operator func !=(other: SignatureType): Bool {
        !(this == other)
    }
}

/**
 * TLS 1.3 analog encapsulate hash and signature algorithm. TLS 1.2 also supports this type.
 * See RFC8446 4.2.3.
 */
public enum SignatureSchemeType <: ToString & Equatable<SignatureSchemeType> {
    /* RSASSA-PKCS1-v1_5 algorithms */
    | RSA_PKCS1_SHA256
    | RSA_PKCS1_SHA384
    | RSA_PKCS1_SHA512

    /* ECDSA algorithms */
    | ECDSA_SECP256R1_SHA256
    | ECDSA_SECP384R1_SHA384
    | ECDSA_SECP521R1_SHA512

    /* RSASSA-PSS algorithms with public key OID rsaEncryption */
    | RSA_PSS_RSAE_SHA256
    | RSA_PSS_RSAE_SHA384
    | RSA_PSS_RSAE_SHA512

    /* EdDSA algorithms */
    | ED25519
    | ED448

    /* RSASSA-PSS algorithms with public key OID RSASSA-PSS */
    | RSA_PSS_PSS_SHA256
    | RSA_PSS_PSS_SHA384
    | RSA_PSS_PSS_SHA512

    public func toString(): String {
        match (this) {
            case RSA_PKCS1_SHA256 => "rsa_pkcs1_sha256"
            case RSA_PKCS1_SHA384 => "rsa_pkcs1_sha384"
            case RSA_PKCS1_SHA512 => "rsa_pkcs1_sha512"
            case ECDSA_SECP256R1_SHA256 => "ecdsa_secp256r1_sha256"
            case ECDSA_SECP384R1_SHA384 => "ecdsa_secp384r1_sha384"
            case ECDSA_SECP521R1_SHA512 => "ecdsa_secp521r1_sha512"
            case RSA_PSS_RSAE_SHA256 => "rsa_pss_rsae_sha256"
            case RSA_PSS_RSAE_SHA384 => "rsa_pss_rsae_sha384"
            case RSA_PSS_RSAE_SHA512 => "rsa_pss_rsae_sha512"
            case ED25519 => "ed25519"
            case ED448 => "ed448"
            case RSA_PSS_PSS_SHA256 => "rsa_pss_pss_sha256"
            case RSA_PSS_PSS_SHA384 => "rsa_pss_pss_sha384"
            case RSA_PSS_PSS_SHA512 => "rsa_pss_pss_sha512"
        }
    }

    public operator func ==(other: SignatureSchemeType): Bool {
        match ((this, other)) {
            case (RSA_PKCS1_SHA256, RSA_PKCS1_SHA256) => true
            case (RSA_PKCS1_SHA384, RSA_PKCS1_SHA384) => true
            case (RSA_PKCS1_SHA512, RSA_PKCS1_SHA512) => true
            case (ECDSA_SECP256R1_SHA256, ECDSA_SECP256R1_SHA256) => true
            case (ECDSA_SECP384R1_SHA384, ECDSA_SECP384R1_SHA384) => true
            case (ECDSA_SECP521R1_SHA512, ECDSA_SECP521R1_SHA512) => true
            case (RSA_PSS_RSAE_SHA256, RSA_PSS_RSAE_SHA256) => true
            case (RSA_PSS_RSAE_SHA384, RSA_PSS_RSAE_SHA384) => true
            case (RSA_PSS_RSAE_SHA512, RSA_PSS_RSAE_SHA512) => true
            case (ED25519, ED25519) => true
            case (ED448, ED448) => true
            case (RSA_PSS_PSS_SHA256, RSA_PSS_PSS_SHA256) => true
            case (RSA_PSS_PSS_SHA384, RSA_PSS_PSS_SHA384) => true
            case (RSA_PSS_PSS_SHA512, RSA_PSS_PSS_SHA512) => true
            case _ => false
        }
    }

    public operator func !=(other: SignatureSchemeType): Bool {
        !(this == other)
    }
}

public enum SignatureAlgorithm <: ToString & Equatable<SignatureAlgorithm> {
    | SignatureAndHashAlgorithm(SignatureType, HashType)
    | SignatureScheme(SignatureSchemeType)

    public func toString(): String {
        match (this) {
            case SignatureAndHashAlgorithm(signature, hash) => "${signature}+${hash}"
            case SignatureScheme(signatureScheme) => signatureScheme.toString()
        }
    }

    public operator func ==(other: SignatureAlgorithm): Bool {
        match ((this, other)) {
            case (SignatureAndHashAlgorithm(s1, h1), SignatureAndHashAlgorithm(s2, h2)) => s1 == s2 && h1 == h2
            case (SignatureScheme(sh1), SignatureScheme(sh2)) => sh1 == sh2
            case _ => false
        }
    }

    public operator func !=(other: SignatureAlgorithm): Bool {
        !(this == other)
    }
}

func sigalgsToByteArray(sigalgs: Array<SignatureAlgorithm>): Array<Byte> {
    let result = StringBuilder(sigalgs[0].toString())
    for (i in 1..sigalgs.size) {
        result.append(r':')
        result.append(sigalgs[i].toString())
    }
    // Add NUL for string, which will be used by C strchr.
    result.append(Rune(0))

    return result.toString().toArray()
}

func setClientSignatureAlgorithms(clientCtx: CPointer<Ctx>, sigalgs: Array<SignatureAlgorithm>): Unit {
    if (sigalgs.isEmpty()) {
        return
    }
    let buf = sigalgsToByteArray(sigalgs)
    for (i in 0..sigalgs.size) {
        var hashType = match (sigalgs[i]) {
            case SignatureAndHashAlgorithm(signature, hash) => "${hash}"
            case _ => continue
        }
        match (hashType) {
            case "SHA512" => continue
            case "SHA384" => continue
            case "SHA256" => continue
            case "SHA224" => continue
            case "SHA1" => continue
            case _ => throw TlsException("Failed to set client signature algorithms, hash type is not supported.")
        }
    }

    ExceptionData.withException<Unit> {
        exception =>
        let raw = unsafe { acquireArrayRawData(buf) }
        try {
            let ret = unsafe { CJ_TLS_SetClientSignatureAlgorithms(clientCtx, raw.pointer, exception) }
            if (ret > 0) {
                return
            }
            let exceptionData = unsafe { exception.read() }
            if (exceptionData.hasException) {
                let fallback = "Failed to set client signature algorithms."
                exceptionData.throwException(fallback: fallback)
            }
        } finally {
            unsafe { releaseArrayRawData(raw) }
        }
    }
}

foreign func CJ_TLS_DYN_SetClientSignatureAlgorithms(
    ctx: CPointer<Ctx>,
    protos: CPointer<Byte>,
    exception: CPointer<ExceptionData>,
    dynMsg: CPointer<DynMsg>
): Int32

func CJ_TLS_SetClientSignatureAlgorithms(
    ctx: CPointer<Ctx>,
    protos: CPointer<Byte>,
    exception: CPointer<ExceptionData>
): Int32 {
    unsafe {
        var dynMsg = DynMsg()
        let res = CJ_TLS_DYN_SetClientSignatureAlgorithms(ctx, protos, exception, inout dynMsg)
        checkDynMsg(dynMsg)
        return res
    }
}
