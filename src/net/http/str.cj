/*
 * Copyright (c) Huawei Technologies Co., Ltd. 2025. All rights reserved.
 * This source file is part of the Cangjie project, licensed under Apache-2.0
 * with Runtime Library Exception.
 *
 * See https://cangjie-lang.cn/pages/LICENSE for license information.
 */

package stdx.net.http

/**
 * Str is a slice of the origin String.
 */
struct Str <: ToString & Equatable<Str> & Hashable {
    let raw: Array<Byte>

    static let empty = Str(Array<Byte>())

    init(data: Array<Byte>) {
        this.raw = data
    }

    init(str: String) {
        this(unsafe { str.rawData() })
    }

    prop size: Int64 {
        get() {
            raw.size
        }
    }

    func byteMatches(fn: (Byte) -> Bool): Bool {
        for (i in 0..size where !fn(raw[i])) {
            return false
        }
        return true
    }

    func splitFirst(b: Byte): ?Str {
        return splitFirst(b, 0)
    }

    func splitFirst(b: Byte, beg: Int64): ?Str {
        if (beg >= size) {
            return None
        }

        for (i in beg..size where raw[i] == b) {
            return slice(beg, end: i)
        }
        return slice(beg)
    }

    func splitLast(b: Byte): Str {
        for (i in (size - 1)..=0 : -1 where raw[i] == b) {
            return slice(i + 1)
        }
        return this
    }

    func splitAllMatch(b: Byte, check: (Str) -> Bool): Bool {
        var beg = 0
        while (let Some(sub) <- splitFirst(b, beg)) {
            if (!check(sub)) {
                return false
            }
            beg += (sub.size + 1) // ignore b
        }
        return true
    }

    func splitAnyMatch(b: Byte, sub: Str): Bool {
        return !splitAllMatch(b, {str => str.trim() != sub})
    }

    func contains(b: Byte): Bool {
        for (i in 0..size where raw[i] == b) {
            return true
        }
        return false
    }

    func trim(): Str {
        var beg = 0
        var end = size - 1

        while (beg <= end && isBlank(raw[beg])) {
            beg++ /* trim left */ }
        while (beg <= end && isBlank(raw[end])) {
            end-- /* trim right */ }

        return Str(raw.slice(beg, end - beg + 1))
    }

    func slice(beg: Int64, end!: Int64 = size): Str {
        if (beg >= end || end > size) {
            return empty
        }
        return Str(raw[beg..end])
    }

    func equals(other: Str, sensitive!: Bool = false): Bool {
        if (this.size != other.size) {
            return false
        }

        if (sensitive) {
            if (size > 100) {
                return this.toString() == other.toString()
            }
            for (i in 0..size where raw[i] != other.raw[i]) {
                return false
            }
            return true
        }

        // this loop can be optimized by encoding bytes as long
        for (i in 0..size where toLower(raw[i]) != toLower(other.raw[i])) {
            return false
        }
        return true
    }

    func endWith(b: Byte): Bool {
        return size != 0 && raw[size - 1] == b
    }

    func startWith(b: Byte): Bool {
        return size != 0 && raw[0] == b
    }

    func removeLast(b: Byte): Str {
        match (endWith(b)) {
            case true => return slice(0, end: size - 1) // remove last byte
            case false => return this
        }
    }

    @OverflowWrapping
    public func hashCode(): Int64 {
        var h: UInt32 = 5381
        for (i in 0..size) {
            h = (h << 5) + h + UInt32(toLower(raw[i]))
        } // strip the highest bit
        h = h & !(UInt32(1) << 31)
        return Int64(h)
    }

    func isEmpty(): Bool {
        return size == 0
    }

    public func toString(): String {
        return String.fromUtf8(raw)
    }

    public operator func ==(other: Str): Bool {
        return equals(other)
    }

    public operator func !=(other: Str): Bool {
        return !equals(other)
    }

    public operator func [](idx: Int64): Byte {
        return raw[idx]
    }

    func isBlank(b: Byte): Bool {
        return b == b' ' || (0X0009 <= b && b <= 0X000D) // HT(09) LF(0A) VT(0B) FF(0C) CR(0D)
    }

    func hasUpper(): Bool {
        for (i in 0..size where raw[i].isAsciiUpperCase()) {
            return true
        }
        return false
    }

    private func toLower(b: Byte): Byte {
        const DIFF: Byte = 122 - 90 // b'z' - b'Z'
        return if (b.isAsciiUpperCase()) {
            b + DIFF
        } else {
            b
        }
    }

    func clone(): Str {
        return Str(raw.clone())
    }
}

extend StringBuilder {
    func append(str: Str) {
        unsafe { appendFromUtf8Unchecked(str.raw) }
    }
}
