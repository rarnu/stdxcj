/*
 * Copyright (c) Huawei Technologies Co., Ltd. 2025. All rights reserved.
 * This source file is part of the Cangjie project, licensed under Apache-2.0
 * with Runtime Library Exception.
 *
 * See https://cangjie-lang.cn/pages/LICENSE for license information.
 */

package stdx.net.http

import std.fs.*
import std.io.*
import std.collection.ArrayList
import stdx.encoding.url.URL

public interface HttpRequestHandler {
    func handle(ctx: HttpContext): Unit
}

public class FuncHandler <: HttpRequestHandler {
    public FuncHandler(let handler: (HttpContext) -> Unit) {}

    /**
     * handle the http request
     *
     * @param ctx request context
     */
    public func handle(ctx: HttpContext): Unit {
        handler(ctx)
    }
}

public class NotFoundHandler <: HttpRequestHandler {
    /**
     * handle the http request with Not Found response
     *
     * @param ctx request context
     */
    public func handle(ctx: HttpContext): Unit {
        notFound(ctx)
    }
}

public func notFound(ctx: HttpContext): Unit {
    handleError(ctx, HttpStatusCode.STATUS_NOT_FOUND)
}

/**
 * handle error
 *
 * @param ctx request context.
 * @param code response status code.
 */
public func handleError(ctx: HttpContext, code: UInt16): Unit {
    let text = STATUS_TEXT.get(code) ?? ""
    ctx.responseBuilder.status(code).header("content-type", "text/plain; charset=utf-8").body("${code} ${text}")
}

public class OptionsHandler <: HttpRequestHandler {
    /**
     * handle the http OPTION request
     *
     * @param ctx request context
     */
    public func handle(ctx: HttpContext): Unit {
        ctx.responseBuilder.header("allow", "OPTIONS, GET, HEAD, POST, PUT, DELETE").header("content-length", "0")
    }
}

public class RedirectHandler <: HttpRequestHandler {
    // The url that will set in Location header
    private var url: String

    // The status code of redirection
    private let code: UInt16

    private var isFullUrl: Bool = false

    /*
     * constructor of RedirectHandler
     *
     * @param url the url set in the response's Location header
     * @param code the response's status code
     *
     * @throws HttpException, if the url is Empty
     *  or the code is not a 3XX code.
     */
    public init(url: String, code: UInt16) {
        if (code >= 400 || code < 300 || code == HttpStatusCode.STATUS_NOT_MODIFIED) {
            throw HttpException("Status code should be 3xx besides 304.")
        }
        if (url.size == 0) {
            throw HttpException("Redirect url cannot be empty.")
        }
        this.code = code
        // resolve url path
        var tmp = URL.parse(url)
        var path = canonicalPath(tmp.path)
        tmp = tmp.replace(path: path)
        if (!tmp.hostName.isEmpty()) {
            isFullUrl = true
        }
        this.url = tmp.toString()
    }

    /*
     * Send a redirect response through ctx
     *
     * @param ctx request context.
     */
    public func handle(ctx: HttpContext): Unit {
        var redirectUrl = url
        if (!isFullUrl && redirectUrl[0] != 47) { // r'/'
            redirectUrl = pathSplit(ctx.request.url.path) + redirectUrl
        }
        redirect(ctx, redirectUrl, code)
    }
}

/**
 * write redirect response
 * body is like <a href="http://..."">STATUS</a>
 */
func redirect(ctx: HttpContext, url: String, code: UInt16): Unit {
    ctx.responseBuilder.status(code)
    ctx.responseBuilder.header("location", url)
    // 304 don't have body 
    if (code != HttpStatusCode.STATUS_NOT_MODIFIED) {
        if (let Some(text) <- STATUS_TEXT.get(code)) {
            let body = StringBuilder("<a href=\"")
            body.append(htmlReplace(url))
            body.append("\">")
            body.append(text)
            body.append("</a>")
            ctx.responseBuilder.body(body.toString())
        }
    }
}

/*
 * Intercept the path of the last slash (/).
 */
func pathSplit(str: String): String {
    var index = str.size - 1
    while (index >= 0 && str[index] != 47) { // r'/'
        index--
    }
    return str[..index + 1]
}

/*
 * Replace special characters in str.
 */
func htmlReplace(str: String): String {
    let sb = StringBuilder()
    for (char in str.runes()) {
        match (char) {
            case r'>' => sb.append("&gt;")
            case r'<' => sb.append("&lt;")
            case r'&' => sb.append("&amp;")
            case r'\"' => sb.append("&#34;")
            case r'\'' => sb.append("&#39;")
            case _ => sb.append(char)
        }
    }
    return sb.toString()
}

public enum FileHandlerType {
    | DownLoad
    | UpLoad
}

/*
 * This class used for provide the handler of handle file.
 */
public class FileHandler <: HttpRequestHandler {
    /* the path of file */
    private let path: String

    /* the type of this file handler, the default value is DownLoad. */
    private let handlerType: FileHandlerType

    /* buffer size used when copying, default size is 64KB */
    private let bufferSize: Int64

    /*
     * Create a new FileHandler object.
     * Construction with parameters.
     *
     * @param path the path of file
     * @param bufferSize buffer size used when copying
     *
     * @throws HttpException if file or directory does not exist
     */
    public init(path: String, handlerType!: FileHandlerType = DownLoad, bufferSize!: Int64 = 64 * 1024) {
        this.path = path
        this.handlerType = handlerType
        if (bufferSize < 4096) {
            this.bufferSize = 4096
        } else {
            this.bufferSize = bufferSize
        }
        match (this.handlerType) {
            case DownLoad => ()
            case UpLoad =>
                if (!exists(path)) {
                    throw HttpException("No such file or directory.")
                }
                var info = FileInfo(path)
                if (info.isSymbolicLink()) {
                    info = FileInfo(SymbolicLink.readFrom(path, recursive: true))
                }
                if (!info.isDirectory()) {
                    throw HttpException("No such file or directory.")
                }
        }
    }

    /*
     * Processing request and build responseWriteStream for FileHandler.
     *
     * @param ctx request context.
     */
    public func handle(ctx: HttpContext): Unit {
        match (this.handlerType) {
            case DownLoad => this.handlerDownLoad(ctx)
            case UpLoad => this.handlerUpLoad(ctx)
        }
    }

    /*
     * @throws FSException if path is empty when File is defined.
     * @throws IllegalArgumentException if path contains null character when File is defined.
     * @throws FSException if buffer is empty or read failed when File is read.
     * @throws FSException if system failed to close file.
     */
    private func handlerDownLoad(ctx: HttpContext): Unit {
        if (ctx.request.method != "GET") {
            handleError(ctx, HttpStatusCode.STATUS_BAD_REQUEST) // 400
            return
        }
        if (!exists(this.path)) {
            notFound(ctx) // 404
            return
        }

        ctx.responseBuilder.header("content-type", getContentType(this.path)).header("transfer-encoding", "chunked")

        let file = File(this.path, Read)
        let writer = HttpResponseWriter(ctx)
        let buf = Array<UInt8>(this.bufferSize, repeat: 0)
        while (true) {
            let readLen = file.read(buf)
            if (readLen > 0) {
                writer.write(buf[..readLen])
            } else {
                break
            }
        }

        file.close()
    }

    /*
     * @throws Exception if length of request's body less than or equal to 0
     */
    private func handlerUpLoad(ctx: HttpContext): Unit {
        if (ctx.request.method != "POST") {
            handleError(ctx, HttpStatusCode.STATUS_BAD_REQUEST) // 400
            return
        }
        // got ??String
        match (ctx.request.headers.getFirst("content-type")) {
            case Some(v) =>
                if (v.startsWith("multipart/form-data")) {
                    let boundary = v.split("=")[1]
                    if (!checkBoundary(boundary)) {
                        handleError(ctx, HttpStatusCode.STATUS_BAD_REQUEST)
                        return
                    }
                    let reader = MultipartReader(ctx.request.body, boundary, bufferSize)
                    let parser = MultipartParser(reader, this.path)
                    parser.parse()
                } else {
                    handleError(ctx, HttpStatusCode.STATUS_BAD_REQUEST) // 400
                    return
                }
            case None =>
                handleError(ctx, HttpStatusCode.STATUS_BAD_REQUEST) // 400
                return
        }
    }

    /*
     * get file extension by file name
     */
    private func getFileExt(s: String) {
        for (i in s.size - 1..0 : -1) {
            let c = s[i]
            if (c == b'\\' || c == b'/') {
                break
            }
            if (c == b'.') {
                return s[i..]
            }
        }
        return ""
    }

    /*
     * get Content type by file extension
     */
    private func getContentType(fileName: String): String {
        let ext = getFileExt(fileName)
        if (ext.isEmpty()) {
            return ""
        }
        if (let Some(v) <- EXT_TYPE_MAP.get(ext)) {
            return v
        }
        return ""
    }
}

/*
 * check out the path for upload path
 */
@When[os != "Windows"]
func checkUploadPath(fileName: String): Bool {
    let filePathList = fileName.split(SLASH)
    for (filePath in filePathList) {
        if (filePath == "..") {
            return false
        }
    }
    return true
}

@When[os == "Windows"]
func checkUploadPath(fileName: String): Bool {
    let filePathList = fileName.replace("\\", SLASH).split(SLASH)
    for (filePath in filePathList) {
        if (filePath == "..") {
            return false
        }
    }
    return true
}

// read multipart/form-data
class MultipartReader {
    let startBoundary: Array<UInt8>
    let buffer: Array<UInt8>
    var curRead = 0
    var curParse = 0
    let remainingData = ArrayList<UInt8>()
    let body: InputStream

    init(body: InputStream, boundary: String, bufSize: Int64) {
        this.body = body
        this.buffer = Array<UInt8>(bufSize, repeat: 0)
        let boundaryBytes = unsafe { boundary.rawData() }
        startBoundary = Array<UInt8>(boundaryBytes.size + 2, repeat: b'-')
        boundaryBytes.copyTo(startBoundary, 0, 2, boundaryBytes.size)
    }

    /**
     * for read boundary line or header field
     * read until \r\n, but return bytes doesn`t contain \r\n
     * @throw HttpStatusException if multipart header size exceed 8M
     */
    func readLine(): Array<UInt8> {
        let start = curParse
        while (true) {
            let readLF = readUntilLF()
            if (!readLF) {
                if (remainingData.size > MAX_LINE_SIZE) {
                    throw HttpStatusException(HttpStatusCode.STATUS_BAD_REQUEST, "Header field too long.")
                } else {
                    continue
                }
            }
            // first byte is \n
            if (curParse == 1 && remainingData.isEmpty()) {
                throw HttpStatusException(HttpStatusCode.STATUS_BAD_REQUEST, "Malformed multipart body.")
            }
            if (curParse == 1 && remainingData[remainingData.size - 1] == CR) {
                break
            }
            if (buffer[curParse - 2] == CR) {
                break
            }
        }
        if (remainingData.isEmpty()) {
            return buffer[start..curParse - 2]
        }
        remainingData.add(all: buffer[..curParse])
        let line = remainingData.toArray()[..remainingData.size - 2]
        remainingData.clear()
        return line
    }

    /**
     * for from buffer until \n
     * @throw ConnectionException if connection closed
     * @throw SocketException if connection closed
     */
    private func readUntilLF(): Bool {
        if (curRead == 0) {
            curRead = body.read(buffer)
            if (curRead == 0) {
                throw HttpStatusException(HttpStatusCode.STATUS_BAD_REQUEST, "Malformed multipart body.")
            }
        }
        var index = curParse
        while (index < curRead && buffer[index] != LF) {
            index++
        }
        var gotLF = false
        if (index < curRead) {
            curParse = index + 1
            gotLF = true
        } else {
            remainingData.add(all: buffer[curParse..curRead])
            curRead = 0
            curParse = 0
        }
        return gotLF
    }

    // read until boundary
    public func readPayload(): (Array<UInt8>, Bool, Bool) {
        var readSectionEnd = false
        var readMultipartEnd = false
        if (let Some(index) <- buffer[curParse..curRead].indexOf(startBoundary)) {
            readSectionEnd = true
            // -2 removes \r\n
            let payload = buffer[curParse..curParse + index - 2]
            curParse += index
            if (curRead >= curParse + startBoundary.size + 2) {
                curParse += startBoundary.size + 2
                // boundary--   ->   body end
                readMultipartEnd = checkBoundaryEnd(buffer[curParse - 2], buffer[curParse - 1]).getOrThrow(
                    {
                        => HttpStatusException(HttpStatusCode.STATUS_BAD_REQUEST, "Malformed multipart body.")
                    })
            } else {
                // not sure \r\n or -- after boundary
                // need read again
                copyAndRead()
                readMultipartEnd = checkBoundaryEnd(buffer[startBoundary.size], buffer[startBoundary.size + 1])
                    .getOrThrow({
                        => HttpStatusException(HttpStatusCode.STATUS_BAD_REQUEST, "Malformed multipart body.")
                    })
                curParse = startBoundary.size + 2
            }
            return (payload, readSectionEnd, readMultipartEnd)
        } else {
            // Data with the end (boundarySize + CRLF.size) length cannot be written to the file.
            // It needs to be moved to the head of the array for the next loop.
            let writeLen = curRead - curParse - (startBoundary.size + 2)
            let payload: Array<UInt8>
            if (writeLen > 0) {
                payload = buffer[curParse..curParse + writeLen]
                curParse += writeLen
            } else {
                copyAndRead()
                payload = "".toArray()
            }
            return (payload, readSectionEnd, readMultipartEnd)
        }
    }

    /**
     * copy unparsed data to head of buffer
     * @throws HttpStatusException when read 0 byte from input stream
     */
    private func copyAndRead(): Unit {
        let copyLen = curRead - curParse
        buffer.copyTo(buffer, curParse, 0, copyLen)
        curRead = copyLen
        let len = body.read(buffer[copyLen..])
        if (len == 0) {
            throw HttpStatusException(HttpStatusCode.STATUS_BAD_REQUEST, "Malformed multipart body.")
        }
        curRead += len
        curParse = 0
    }

    // there`s three status at boundary end
    // read boundary--    represent the body read finish, return true in this status
    // read boundary\r\n  represent one part of body read finish and 
    // there`s other part behind, return false in this status
    // if boundary is not followed by "--" or "\r\n", then it is illegal, return None
    private func checkBoundaryEnd(a: UInt8, b: UInt8): ?Bool {
        let boundaryEnd = a == b'-' && b == b'-'
        if (!boundaryEnd && (a != CR || b != LF)) {
            return None
        }
        return boundaryEnd
    }
}

class MultipartParser {
    let headers = HttpHeaders()
    var parseEnd = false

    MultipartParser(let reader: MultipartReader, let basePath: String) {}

    /**
     * parse multipart/form-data
     * @throw HttpStatusException if parse form data failed
     * @throw FSException if file exception occurred
     * @throw ConnectionException if connection closed
     * @throw SocketException if connection closed
     */
    func parse(): Unit {
        // first line should be "--${boundary}"
        let firstLine = reader.readLine()
        if (firstLine != reader.startBoundary) {
            throw HttpStatusException(HttpStatusCode.STATUS_BAD_REQUEST, "Malformed multipart body.")
        }
        while (!parseEnd) {
            parseEnd = parseSection()
        }
    }

    private func parseSection(): Bool {
        // headerField.size = 0 -> read \r\n\r\n
        while (true) {
            let headerField = reader.readLine()
            if (headerField.size <= 0) {
                break
            }
            parseHeaderLine(headerField)
        }

        parseContentDisposition(headers)
        let fileName = match (headers.getFirst("filename")) {
            case Some(name) => name
            case None => throw HttpStatusException(HttpStatusCode.STATUS_BAD_REQUEST, "Filename not found.")
        }
        if (!checkUploadPath(fileName)) {
            throw HttpStatusException(HttpStatusCode.STATUS_BAD_REQUEST, "The filename field contains \"..\".")
        }
        let file = createFile(fileName)
        var parseEnd = false
        try {
            parseEnd = writeFile(file)
        } catch (e: Exception) {
            if (!file.isClosed()) {
                file.close()
            }
            if (exists(concatPath(fileName))) {
                remove(concatPath(fileName))
            }
            throw e
        } finally {
            if (!file.isClosed()) {
                file.close()
            }
        }
        // clear headers map for next section parse
        if (!parseEnd) {
            headers.clear()
        }
        return parseEnd
    }

    private func createFile(fileName: String): File {
        let fullPath = concatPath(fileName)
        if (exists(fullPath)) {
            throw FSException("File already exist.")
        }
        File(fullPath, Write)
    }

    private func concatPath(fileName: String): String {
        this.basePath + SLASH + fileName
    }

    private func parseHeaderLine(header: Array<UInt8>) {
        let colonIndex = match (header.indexOf(b':')) {
            case Some(i) => i
            case None => throw HttpStatusException(HttpStatusCode.STATUS_BAD_REQUEST, "No `:` in header.")
        }
        let key = String.fromUtf8(header[0..colonIndex])
        let val = String.fromUtf8(header[colonIndex + 1..header.size]).trimAscii()
        headers.set(key, val)
    }

    private func writeFile(file: File): Bool {
        var sectionEnd = false
        var multipartEnd = false
        while (!sectionEnd) {
            let bytes: Array<UInt8>
            (bytes, sectionEnd, multipartEnd) = reader.readPayload()
            file.write(bytes)
        }
        file.close()
        return multipartEnd
    }

    /*
     * ------WebKitFormBoundarypPgEUiV3g1leAAx3
     *  Content-Disposition: form-data; name="myFile"; filename="upload.html"
     *
     *  ...
     * ------WebKitFormBoundarypPgEUiV3g1leAAx3--
     * parser this data and set name and filename to header
     *
     * @throws HttpStatusException if header failed to match "Content-Disposition"
     * @throws HttpStatusException if header value cannot parse
     */
    private func parseContentDisposition(header: HttpHeaders): Unit {
        match (header.getFirst("content-disposition")) {
            case Some(v) =>
                let elements = v.split(";")
                if (!(elements[0].trimAscii() == "form-data")) {
                    throw HttpStatusException(HttpStatusCode.STATUS_BAD_REQUEST,
                        "Not supported content-disposition type.")
                }
                for (i in 1..elements.size) {
                    let element = elements[i].trimAscii().split("=", 2)
                    if (element.size < 2) {
                        throw HttpStatusException(HttpStatusCode.STATUS_BAD_REQUEST, "Illegal multipart header value.")
                    }
                    let key = element[0]
                    let value = element[1]
                    if (value[0] != b'\"' || value[value.size - 1] != b'\"') {
                        throw HttpStatusException(HttpStatusCode.STATUS_BAD_REQUEST, "Illegal multipart header value.")
                    }
                    header.set(key, value[1..value.size - 1])
                }
            case _ => throw HttpStatusException(HttpStatusCode.STATUS_BAD_REQUEST, "The content-disposition not found.")
        }
    }
}
