/*
 * Copyright (c) Huawei Technologies Co., Ltd. 2025. All rights reserved.
 * This source file is part of the Cangjie project, licensed under Apache-2.0
 * with Runtime Library Exception.
 *
 * See https://cangjie-lang.cn/pages/LICENSE for license information.
 */

package stdx.net.http

import std.collection.*

/*
 * This enum contains all frame types in spec, FIELDS frame is HEADERS + CONTINUATION
 */
enum FrameTypes {
    Data
    | Headers
    | Priority
    | RstStream
    | Settings
    | PushPromise
    | Ping
    | Goaway
    | WindowUpdate
    | Continuation
    |
        // defined in RFC 9218
        PriorityUpdate
    | Fields
    | Unknown

    func value(): UInt8 {
        match (this) {
            case Data => 0
            case Headers => 1
            case Priority => 2
            case RstStream => 3
            case Settings => 4
            case PushPromise => 5
            case Ping => 6
            case Goaway => 7
            case WindowUpdate => 8
            case Continuation => 9
            case PriorityUpdate => 10
            case Fields => 13
            case _ => 14
        }
    }

    static func matchType(flag: UInt8): FrameTypes {
        match (flag) {
            case 0 => Data
            case 1 => Headers
            case 2 => Priority
            case 3 => RstStream
            case 4 => Settings
            case 5 => PushPromise
            case 6 => Ping
            case 7 => Goaway
            case 8 => WindowUpdate
            case 9 => Continuation
            case 10 => PriorityUpdate
            case 13 => Fields
            case _ => Unknown
        }
    }
}

/*
 * the basic structure of frame is:
 * HTTP Frame {
 *   Length (24),
 *   Type (8),
 *
 *   Flags (8),
 *
 *   Reserved (1),
 *   Stream Identifier (31),
 *
 *   Frame Payload (..),
 * }
 */
open class Frame <: ToString {
    // the payloadLen is an unsigned 24-bit integer in units of octets. 
    // the default max value in spec is 2^14 (16,384) and theoretical maximum is 16,777,216
    // since we don`t have UInt24, use UInt32 instead, but the first byte must be zero 
    var payloadLen: UInt32 = 0
    var frameType: FrameTypes = FrameTypes.Unknown
    var flags: UInt8 = 0
    var streamId: UInt32 = 0
    var payloadWrapper = ArrayWrapper.empty

    static func read(conn: BufferedConn, maxFrameSize!: UInt32 = MIN_FRAME_SIZE, headerBuf!: ?Array<Byte> = None,
        arrayPool!: ?ArrayPool = None): ?Frame {
        // conn.read must read until the buf is full, no need to check
        let header = headerBuf ?? Array<UInt8>(FRAME_HEAD_LEN, repeat: 0)
        conn.readFull(header)

        let payloadLen64 = Int64(readUInt32(header[..3]))
        if (payloadLen64 > Int64(maxFrameSize)) {
            throw HttpConnectionException(ProtocolError, "Payload length exceed settings.")
        }
        // payloadWrapper is the array which cover payload, it may larger than payload
        // the valid part of payloadWrapper is payloadWrapper[..payloadLength]
        let payloadWrapper = arrayPool?.get(payloadLen64) ?? ArrayWrapper(payloadLen64)
        if (payloadLen64 != 0) {
            conn.readFull(payloadWrapper.data)
        }
        return Frame.decode(header, payloadWrapper, payloadLen64, arrayPool: arrayPool)
    }

    public open func writeTo(_: BufferedWriter): Unit {}

    // when read: recycle when consume the frame in readBody (dataFrame)
    // recycle HeadersFrame & ContinuationFrame after Decoder.decode
    // recycle other frames after parse a frame
    // when write: recycle after write the frame to conn
    func recyclePayload(arrayPool: ?ArrayPool) {
        arrayPool?.put(payloadWrapper)
    }

    // @throws HttpStreamException in decode window_update
    // @throws HttpConnectionException
    static func decode(header: Array<UInt8>, payloadWrapper: ArrayWrapper, payloadLen64: Int64,
        arrayPool!: ?ArrayPool = None): ?Frame {
        let frameType = FrameTypes.matchType(header[3])
        let flag = header[4]
        var streamId = readUInt32(header[5..])

        // the reserved bit is 1, rfc said the reserved bit MUST be ignored when receiving 
        if (streamIdOverflow(streamId)) {
            streamId = streamId - MAX_STREAM_ID - 1
        }
        return match (frameType) {
            case Data => DataFrame(streamId, flag, payloadWrapper, payloadLen64)
            case Headers => HeadersFrame(streamId, flag, payloadWrapper, payloadLen64)
            case Continuation => ContinuationFrame(streamId, flag, payloadWrapper, payloadLen64)
            case Priority => None // we support new PRIORITY_UPDATE, old PRIORITY not supported
            case RstStream =>
                let frame = RstStreamFrame(streamId, payloadWrapper, payloadLen64)
                frame.recyclePayload(arrayPool)
                frame
            case Settings =>
                let frame = SettingsFrame(streamId, flag, payloadWrapper, payloadLen64)
                frame.recyclePayload(arrayPool)
                frame
            case PushPromise => PushFrame(streamId, flag, payloadWrapper, payloadLen64)
            case Ping =>
                let frame = PingFrame(streamId, flag, payloadWrapper, payloadLen64)
                frame.recyclePayload(arrayPool)
                frame
            case Goaway =>
                let frame = GoawayFrame(streamId, payloadWrapper, payloadLen64)
                frame.recyclePayload(arrayPool)
                frame
            case WindowUpdate =>
                let frame = WindowUpdateFrame(streamId, payloadWrapper, payloadLen64)
                frame.recyclePayload(arrayPool)
                frame
            case PriorityUpdate =>
                let frame = PriorityUpdateFrame(streamId, payloadWrapper, payloadLen64)
                frame.recyclePayload(arrayPool)
                frame
            case _ => None // MUST ignore and discard frames of unknown types
        }
    }

    public open func encode(): Array<UInt8> {
        return Array<UInt8>(0, repeat: 0)
    }

    public open func toString(): String {
        return "frame"
    }
}

func writeHead(conn: BufferedWriter, frameType: FrameTypes, streamId: UInt32, flags: UInt8, payloadLen: UInt32): Unit {
    if (payloadLen > MAX_FRAME_SIZE) {
        throw HttpConnectionException(ProtocolError, "Payload length overflow.")
    }
    conn.writePayloadLen(payloadLen)
    conn.write(frameType.value())
    conn.write(flags)
    conn.writeUInt32(streamId)
}

class DataFrame <: Frame {
    var padded: Bool = false
    var padLen: UInt8 = 0
    var streamEnd: Bool = false

    // for read
    init(id: UInt32, flag: UInt8, payloadWrapper: ArrayWrapper, payloadLen64: Int64) {
        if (!checkStreamId(id)) {
            throw HttpConnectionException(ProtocolError, "Illegal id.")
        }
        this.frameType = Data
        this.streamId = id
        this.flags = flag
        this.payloadLen = UInt32(payloadLen64)
        this.streamEnd = (this.flags & STREAM_END) == STREAM_END
        this.padded = (this.flags & PADDED) == PADDED
        this.payloadWrapper = payloadWrapper
        let payload = payloadWrapper.data
        if (this.padded) {
            if (payloadLen64 == 0) {
                throw HttpConnectionException(ProtocolError, "Illegal data padding.")
            }
            this.padLen = payload[0]
            if (Int64(padLen) > payloadLen64 - 1) {
                throw HttpConnectionException(ProtocolError, "Illegal data padding.")
            }
            // padding cannot have non zero byte
            if (!checkPad(payload[payloadLen64 - Int64(padLen)..])) {
                throw HttpConnectionException(ProtocolError, "Illegal padding.")
            }
        }
    }

    // for write
    init(id: UInt32, payloadWrapper: ArrayWrapper, payloadLen64: Int64, padLen!: UInt8 = 0, last!: Bool = false) {
        if (!checkStreamId(id)) {
            throw HttpConnectionException(ProtocolError, "Illegal id.")
        }
        if (padLen > 0) {
            padded = true
            this.padLen = padLen
        }
        this.frameType = Data
        this.streamEnd = last
        this.streamId = id
        this.payloadLen = UInt32(payloadLen64)
        this.payloadWrapper = payloadWrapper
        this.flags = getFlag()
        // if padded: first byte of payload is pad length, should add 1 in payloadLen 
        if (padded) {
            this.payloadLen += UInt32(padLen) + 1
        }
    }

    // for write
    init(id: UInt32, payload: Array<Byte>, payloadLen64: Int64, padLen!: UInt8 = 0, last!: Bool = false) {
        if (!checkStreamId(id)) {
            throw HttpConnectionException(ProtocolError, "Illegal id.")
        }
        if (padLen > 0) {
            padded = true
            this.padLen = padLen
        }
        this.frameType = Data
        this.streamEnd = last
        this.streamId = id
        this.payloadLen = UInt32(payloadLen64)
        this.payloadWrapper = ArrayWrapper(payload)
        this.flags = getFlag()
        // if padded: first byte of payload is pad length, should add 1 in payloadLen 
        if (padded) {
            this.payloadLen += UInt32(padLen) + 1
        }
    }

    prop size: Int64 {
        get() {
            Int64(payloadLen) - Int64(padLen)
        }
    }

    prop data: Array<Byte> {
        get() {
            payloadWrapper.data
        }
    }

    public func writeTo(conn: BufferedWriter): Unit {
        writeHead(conn, Data, streamId, flags, payloadLen)
        conn.write(data[..Int64(payloadLen)])
        conn.flush()
    }

    private func getFlag(): UInt8 {
        var flag: UInt8 = 0
        // |= is faster than +=
        if (this.padded) {
            flag |= PADDED
        }
        if (this.streamEnd) {
            flag |= STREAM_END
        }
        return flag
    }

    public func toString(): String {
        let sb = StringBuilder("Data Frame [")
        sb.append("Length: ${payloadLen} ")
        sb.append("Padded: ${padded} ")
        sb.append("EndStream: ${streamEnd} ")
        sb.append("Stream id: ${streamId} ")
        if (padded) {
            sb.append("Pad Length: ${padLen} ")
        }
        sb.append(r']')
        sb.toString()
    }
}

class HeadersFrame <: Frame {
    var padded: Bool = false
    var padLen: UInt8 = 0
    var hasPriority = false
    var weight: ?UInt8 = None
    var streamDependency: ?UInt32 = None
    var headerEnd = false
    var streamEnd: Bool = false

    // for read
    init(id: UInt32, flag: UInt8, payloadWrapper: ArrayWrapper, payloadLen64: Int64) {
        if (!checkStreamId(id)) {
            throw HttpConnectionException(ProtocolError, "Illegal stream id.")
        }
        this.frameType = Headers
        this.streamId = id
        this.flags = flag
        this.payloadLen = UInt32(payloadLen64)
        this.payloadWrapper = payloadWrapper
        let payload = payloadWrapper.data
        parseFlag()
        if (this.padded) {
            if (payloadLen == 0) {
                throw HttpConnectionException(ProtocolError, "Illegal headers padding.")
            }
            this.padLen = payload[0]
            if (Int64(padLen) > payloadLen64 - 1) {
                throw HttpConnectionException(ProtocolError, "Illegal headers padding.")
            }
            if (!checkPad(payload[payloadLen64 - Int64(padLen)..])) {
                throw HttpConnectionException(ProtocolError, "Illegal headers padding.")
            }
        }
        if (this.hasPriority) {
            let start = if (padded) {
                1
            } else {
                0
            }
            if (payloadLen64 < 5) {
                throw HttpConnectionException(ProtocolError, "Illegal headers frame.")
            }
            this.streamDependency = readUInt32(payload[start..4])
            if (!checkStreamId(id)) {
                throw HttpConnectionException(ProtocolError, "Illegal stream id.")
            }
            this.weight = payload[start + 4]
        }
    }

    prop fieldBlock: Array<Byte> {
        get() {
            var start = 0
            var end = Int64(payloadLen)
            if (padded) {
                start += 1
                end -= Int64(padLen)
            }
            if (hasPriority) {
                start += 5
            }
            payloadWrapper.data[start..end]
        }
    }

    private func parseFlag(): Unit {
        this.headerEnd = (this.flags & HEADERS_END) == HEADERS_END
        this.streamEnd = (this.flags & STREAM_END) == STREAM_END
        this.padded = (this.flags & PADDED) == PADDED
        this.hasPriority = (this.flags & HAS_PRIORITY) == HAS_PRIORITY
    }

    public func toString(): String {
        let sb = StringBuilder("Headers Frame [ ")
        sb.append("Length: ${payloadLen} ")
        sb.append("Has Priority: ${hasPriority} ")
        sb.append("Padded: ${padded} ")
        sb.append("EndHeader: ${headerEnd} ")
        sb.append("EndStream: ${streamEnd} ")
        sb.append("Stream id: ${streamId} ")
        if (padded) {
            sb.append("Pad Length: ${padLen} ")
        }
        if (hasPriority) {
            sb.append("Stream Dependency: ${streamDependency}")
            sb.append("Weight: ${padLen} ")
        }
        sb.append(r']')
        return sb.toString()
    }
}

class ContinuationFrame <: Frame {
    var headerEnd = false

    // for read
    init(id: UInt32, flag: UInt8, payloadWrapper: ArrayWrapper, payloadLen64: Int64) {
        if (!checkStreamId(id)) {
            throw HttpConnectionException(ProtocolError, "Illegal id.")
        }
        this.frameType = Continuation
        this.streamId = id
        this.flags = flag
        this.payloadLen = UInt32(payloadLen64)
        this.payloadWrapper = payloadWrapper
        parseFlag()
    }

    prop fieldBlock: Array<UInt8> {
        get() {
            payloadWrapper.data
        }
    }

    private func parseFlag(): Unit {
        this.headerEnd = (this.flags & HEADERS_END) == HEADERS_END
    }

    public func toString(): String {
        let sb = StringBuilder()
        sb.append("Continuation Frame [ ")
        sb.append("Length: ${payloadLen} ")
        sb.append("EndHeader: ${headerEnd} ")
        sb.append("Stream id: ${streamId} ]")
        sb.toString()
    }
}

class PriorityFrame <: Frame {
    public func toString(): String {
        return "priority not supported"
    }
}

class RstStreamFrame <: Frame {
    var errorCode: UInt32 = 0

    // for read
    init(id: UInt32, payloadWrapper: ArrayWrapper, payloadLen64: Int64) {
        if (!checkStreamId(id)) {
            throw HttpConnectionException(ProtocolError, "Illegal id.")
        }
        if (payloadLen64 != 4) {
            throw HttpConnectionException(ProtocolError, "RstStream frame payload illegal value:${payloadLen64}.")
        }
        // RstStreamFrame payload is a 4Bytes code
        this.payloadLen = 4
        this.frameType = RstStream
        this.streamId = id
        this.payloadWrapper = payloadWrapper
        this.errorCode = readUInt32(payloadWrapper.data[..4])
    }

    // for write
    init(id: UInt32, errorCode: UInt32) { // no check on error code, in case there is customized code or new version of error code
        if (!checkStreamId(id)) {
            throw HttpConnectionException(ProtocolError, "Illegal id.")
        }
        this.payloadLen = 4
        this.frameType = RstStream
        this.streamId = id
        this.errorCode = errorCode
    }

    public func writeTo(conn: BufferedWriter): Unit {
        writeHead(conn, RstStream, streamId, flags, 4)
        conn.writeUInt32(errorCode)
        conn.flush()
    }

    public func toString(): String {
        let sb = StringBuilder("RstStream Frame [ ")
        sb.append("Stream id: ${streamId} ")
        sb.append("errorCode: ${errorCode} ]")
        return sb.toString()
    }
}

class SettingsFrame <: Frame {
    var ack: Bool = false
    var settings: Map<UInt16, UInt32> = HashMap<UInt16, UInt32>()

    // for read
    init(id: UInt32, flag: UInt8, payloadWrapper: ArrayWrapper, payloadLen64: Int64) {
        if (id != 0) {
            throw HttpConnectionException(ProtocolError, "Illegal id.")
        }
        if (payloadLen64 % 6 != 0) {
            throw HttpConnectionException(ProtocolError, "Illegal setting length.")
        }
        this.flags = flag
        parseFlag()
        this.payloadLen = UInt32(payloadLen64)
        this.payloadWrapper = payloadWrapper
        if (ack && payloadLen != 0) {
            throw HttpConnectionException(ProtocolError,
                "Ack settings frame can not have payload, current payloadLen:${payloadLen}.")
        }
        this.frameType = Settings
        this.streamId = 0
        parseSettings(payloadWrapper.data)
    }

    // for write
    init(settings: Map<UInt16, UInt32>) {
        this.payloadLen = UInt32(settings.size * 6)
        this.frameType = Settings
        this.streamId = 0
        this.ack = false
        this.flags = getFlag()
        this.settings = settings
    }

    // for ack
    init() {
        this.payloadLen = 0
        this.frameType = Settings
        this.streamId = 0
        this.ack = true
        this.flags = getFlag()
    }

    public func writeTo(conn: BufferedWriter): Unit {
        writeHead(conn, Settings, streamId, flags, payloadLen)
        if (!this.ack) {
            for ((k, v) in settings) {
                conn.writeUInt16(k)
                conn.writeUInt32(v)
            }
        }
        conn.flush()
    }

    private func parseSettings(payload: Array<UInt8>): Unit {
        if (payload.size == 0) {
            return
        }
        var tmp = payload
        for (i in 0..payload.size : 6) {
            var key = readUInt16(tmp[i..i + 2])
            var value = readUInt32(tmp[i + 2..i + 6])
            this.settings.add(key, value)
        }
        return
    }

    private func parseFlag(): Unit {
        this.ack = (this.flags & ACK) == ACK
    }

    private func getFlag(): UInt8 {
        var flag: UInt8 = 0
        if (this.ack) {
            flag |= ACK
        }
        return flag
    }

    public func toString(): String {
        let sb = StringBuilder("Settings Frame [ ")
        sb.append("Ack: ${ack} ")
        if (!ack) {
            sb.append("Settings {")
            for ((k, v) in settings) {
                sb.append("${k}: ${v};")
            }
            sb.append(r'}')
        }
        sb.append(r']')
        return sb.toString()
    }
}

class PushFrame <: Frame {
    var padded: Bool = false
    var padLen: UInt8 = 0
    var headerEnd: Bool = false
    var promisedId: UInt32 = 0

    // for read
    init(id: UInt32, flag: UInt8, payloadWrapper: ArrayWrapper, payloadLen64: Int64) {
        if (!checkStreamId(id)) {
            throw HttpConnectionException(ProtocolError, "Illegal stream id.")
        }
        this.flags = flag
        parseFlag()
        this.payloadLen = UInt32(payloadLen64)
        this.payloadWrapper = payloadWrapper
        this.frameType = PushPromise
        this.streamId = id
        let payload = payloadWrapper.data
        if (this.padded) {
            if (payloadLen == 0) {
                throw HttpConnectionException(ProtocolError, "Illegal push padding.")
            }
            padLen = payload[0]
            if (Int64(padLen) > payloadLen64 - 1) {
                throw HttpConnectionException(ProtocolError, "Illegal push padding.")
            }
            if (!checkPad(payload[payloadLen64 - Int64(padLen)..])) {
                throw HttpConnectionException(ProtocolError, "Illegal padding.")
            }
        }
        if (payloadLen64 < 4) {
            throw HttpConnectionException(ProtocolError, "Illegal push frame.")
        }
        promisedId = readUInt32(payload[0..4])
        if (!checkStreamId(promisedId)) {
            throw HttpConnectionException(ProtocolError, "Illegal stream id.")
        }
    }

    prop fieldBlock: Array<Byte> {
        get() {
            return if (padded) {
                payloadWrapper.data[5..(Int64(payloadLen) - Int64(padLen))]
            } else {
                payloadWrapper.data[4..]
            }
        }
    }

    private func parseFlag(): Unit {
        this.headerEnd = (this.flags & HEADERS_END) == HEADERS_END
        this.padded = (this.flags & PADDED) == PADDED
    }

    public func toString(): String {
        let sb = StringBuilder("PushPromise Frame [ ")
        sb.append("Length ${payloadLen} ")
        sb.append("Stream id: ${streamId} ")
        sb.append("Padded: ${padded} ")
        sb.append("Header End: ${headerEnd} ")
        sb.append("Promised Stream: ${promisedId}")
        if (padded) {
            sb.append("PadLen: ${padLen}")
        }
        sb.append(r']')
        return sb.toString()
    }
}

class PingFrame <: Frame {
    var ack: Bool = false
    var payload: Array<UInt8>

    // for read
    init(id: UInt32, flag: UInt8, payloadWrapper: ArrayWrapper, payloadLen64: Int64) {
        if (id != 0) {
            throw HttpConnectionException(ProtocolError, "Illegal id.")
        }
        if (payloadLen64 != 8) {
            throw HttpConnectionException(ProtocolError, "Opaque data must be 8 bytes.")
        }
        // PingFrame payload is a 8Bytes opaque data
        this.payloadWrapper = payloadWrapper
        this.flags = flag
        this.ack = (this.flags & ACK) == ACK
        this.payloadLen = 8
        this.frameType = Ping
        this.streamId = id
        this.payload = payloadWrapper.data[..payloadLen64].clone()
    }

    // for write
    // make sure payload.size = 8
    init(isAck!: Bool = false, payload!: Array<UInt8> = Array<UInt8>(8, repeat: 0)) {
        this.payloadLen = 8
        this.frameType = Ping
        this.streamId = 0
        this.ack = isAck
        this.payload = payload
        this.flags = getFlag()
    }

    public func writeTo(conn: BufferedWriter): Unit {
        writeHead(conn, Ping, streamId, flags, payloadLen)
        conn.write(payload)
        conn.flush()
    }

    private func getFlag(): UInt8 {
        var flag: UInt8 = 0
        if (this.ack) {
            flag |= ACK
        }
        return flag
    }

    public func toString(): String {
        return "Ping Frame [ Ack: ${ack} ]"
    }
}

class GoawayFrame <: Frame {
    let lastStreamId: UInt32
    var errorCode: UInt32
    let debugData: Array<UInt8>

    // for read
    init(id: UInt32, payloadWrapper: ArrayWrapper, payloadLen64: Int64) {
        if (id != 0) {
            throw HttpConnectionException(ProtocolError, "Illegal id.")
        }
        if (payloadLen64 < 8) {
            throw HttpConnectionException(ProtocolError, "Goaway should have at least 8 bytes payload.")
        }
        this.payloadLen = UInt32(payloadLen64)
        this.payloadWrapper = payloadWrapper
        this.frameType = Goaway
        this.streamId = id
        let payload = payloadWrapper.data
        lastStreamId = readUInt32(payload[0..4])
        errorCode = readUInt32(payload[4..8])
        if (payloadLen64 > 8) {
            debugData = payload[8..].clone()
        } else {
            debugData = Array<UInt8>(0, repeat: 0)
        }
    }

    // for write
    init(lastStreamId: UInt32, errorCode: UInt32, data!: ?Array<UInt8> = None) {
        this.debugData = data ?? Array<UInt8>(0, repeat: 0)
        this.payloadLen = UInt32(debugData.size) + 8
        this.frameType = Goaway
        this.streamId = 0
        this.lastStreamId = lastStreamId
        this.errorCode = errorCode
    }

    public func writeTo(conn: BufferedWriter): Unit {
        writeHead(conn, Goaway, streamId, flags, payloadLen)
        conn.writeUInt32(lastStreamId)
        conn.writeUInt32(errorCode)
        conn.write(debugData)
        conn.flush()
    }

    public func toString(): String {
        let sb = StringBuilder()
        sb.append("Goaway Frame [ ")
        sb.append("Last Stream Id: ${lastStreamId} ")
        sb.append("Error Code: ${errorCode} ")
        sb.append("Debug data: ${String.fromUtf8(debugData)} ]")
        return sb.toString()
    }
}

class WindowUpdateFrame <: Frame {
    let increment: UInt32
    init(id: UInt32, payloadWrapper: ArrayWrapper, payloadLen64: Int64) {
        if (payloadLen64 != 4) {
            throw HttpConnectionException(ProtocolError, "Illegal window update frame, payload length should be 4.")
        }
        // WindowUpdateFrame payload is a 4Bytes number
        this.payloadLen = 4
        this.payloadWrapper = payloadWrapper
        this.frameType = WindowUpdate
        this.streamId = id
        this.increment = readUInt32(payloadWrapper.data[..4])
        if (this.increment == 0 || increment > MAX_WINDOW) {
            if (id == 0) {
                throw HttpConnectionException(ProtocolError, "Illegal increment.")
            } else {
                throw HttpStreamException(ProtocolError, "Illegal increment.")
            }
        }
    }

    init(id: UInt32, increment: UInt32) {
        if (streamIdOverflow(id)) {
            throw HttpConnectionException(ProtocolError, "Illegal id.")
        }
        if (increment == 0 || increment > MAX_WINDOW) {
            throw HttpConnectionException(ProtocolError, "Illegal increment.")
        }
        this.payloadLen = 4
        this.frameType = WindowUpdate
        this.streamId = id
        this.increment = increment
    }

    public func writeTo(conn: BufferedWriter): Unit {
        writeHead(conn, WindowUpdate, streamId, flags, payloadLen)
        conn.writeUInt32(increment)
        conn.flush()
    }

    public func toString(): String {
        let sb = StringBuilder()
        sb.append("WindowUpdateFrame Frame [ ")
        sb.append("Stream id: ${streamId} ")
        sb.append("Increment: ${increment} ]")
        return sb.toString()
    }
}

class PriorityUpdateFrame <: Frame {
    let prioritizedId: UInt32
    let fieldValue: String

    init(id: UInt32, payloadWrapper: ArrayWrapper, payloadLen64: Int64) {
        if (id != 0) {
            throw HttpConnectionException(ProtocolError, "Illegal stream id.")
        }
        this.payloadLen = UInt32(payloadLen64)
        this.frameType = PriorityUpdate
        this.streamId = id
        if (payloadLen < 4) {
            throw HttpConnectionException(ProtocolError, "Illegal priority_update frame.")
        }
        this.prioritizedId = readUInt32(payloadWrapper.data[0..4])
        if (!checkStreamId(prioritizedId)) {
            throw HttpConnectionException(ProtocolError, "Illegal stream id.")
        }
        this.fieldValue = String.fromUtf8(payloadWrapper.data[4..]) // copy
    }

    init(prioritizedId: UInt32, fieldValue: String) {
        if (!checkStreamId(prioritizedId)) {
            throw HttpConnectionException(ProtocolError, "Illegal stream id")
        }
        this.fieldValue = fieldValue
        this.payloadLen = UInt32(fieldValue.size) + 4
        this.frameType = PriorityUpdate
        this.streamId = 0
        this.prioritizedId = prioritizedId
    }

    public func writeTo(conn: BufferedWriter): Unit {
        writeHead(conn, PriorityUpdate, streamId, flags, payloadLen)
        conn.writeUInt32(prioritizedId)
        unsafe { conn.write(fieldValue.rawData()) }
        conn.flush()
    }

    public func toString(): String {
        let sb = StringBuilder()
        sb.append("PriorityUpdateFrame Frame [ ")
        sb.append("Prioritized Stream id: ${prioritizedId} ")
        sb.append("Field value: ${fieldValue} ]")
        return sb.toString()
    }
}

class FieldsFrame <: Frame { // XXX: add pad if need
    var fields: FieldsList
    var frames: ArrayList<Frame> = ArrayList<Frame>()
    let streamEnd: Bool
    // push promised id cannot be zero, so use zero as default value means not push
    let pushId: UInt32

    init(id: UInt32, fields: FieldsList, last!: Bool = false, pushId!: UInt32 = 0) {
        this.streamId = id
        this.fields = fields
        this.streamEnd = last
        this.pushId = pushId
        this.frameType = Fields
    }

    public func writeTo(fieldsWriter: FieldsWriter, encoder: Encoder): Unit {
        encoder.encodeTo(fields, fieldsWriter)
    }

    public func toString(): String {
        let sb = StringBuilder()
        sb.append("Fields Frame for id:${streamId} , fields: ")
        for ((k, v) in fields) {
            sb.append("${k}: ${v}, ")
        }
        return sb.toString()
    }
}

class ConnectRstStreamFrame <: Frame {
    var errorCode: UInt32 = 0
    let rstFrame: RstStreamFrame
    init(frame: RstStreamFrame) {
        rstFrame = frame
    }

    public func encode(): Array<UInt8> {
        return rstFrame.encode()
    }

    public func writeTo(conn: BufferedWriter): Unit {
        rstFrame.writeTo(conn)
    }

    public func toString(): String {
        rstFrame.toString()
    }
}

// for server 
class UnblockFrame <: Frame {
    public func toString(): String {
        return "unblock frame"
    }
}
