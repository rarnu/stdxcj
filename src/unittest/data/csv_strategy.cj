/*
 * Copyright (c) Huawei Technologies Co., Ltd. 2025. All rights reserved.
 * This source file is part of the Cangjie project, licensed under Apache-2.0
 * with Runtime Library Exception.
 *
 * See https://cangjie-lang.cn/pages/LICENSE for license information.
 */

package stdx.unittest.data

import std.unittest.common.*
import std.convert.*
import std.fs.*
import std.math.*
import std.collection.*
import std.io.*
import stdx.serialization.serialization.*

const TSV_DELIMITER = r'\t'
const CSV_DEFAULT_DELIMITER = r','
const CSV_DEFAULT_QUOTE = r'"'
const CSV_DEFAULT_ESCAPE = r'"'

class CsvParser {
    private var buffer = None<Array<Rune>>
    private var bufferStartIdx = 0

    private var currentColumnData = ArrayList<Rune>()
    private var currentColumnIdx = 0u64 // index of column related to header (skips considered)
    private var currentRawColumnIdx = 0u64 // index of column related to input raw structure (skips not considered)

    private var currentRowData = HashMap<String, String>()
    private var currentRowIdx = 0u64

    private let _data = ArrayList<HashMap<String, String>>()

    private let header = ArrayList<String>()
    private var isHeaderInitialized: Bool
    private var isHeaderRow: Bool

    private var isEscaped = false
    private var isQuoted = false
    private var isCommented = false

    CsvParser(
        header!: Header = FirstRow,
        let delimiter!: Rune = CSV_DEFAULT_DELIMITER,
        let quoteChar!: Rune = CSV_DEFAULT_QUOTE,
        let escapeChar!: Rune = CSV_DEFAULT_ESCAPE,
        let commentChar!: Option<Rune> = None,
        let skipRows!: Array<UInt64> = [],
        let skipColumns!: Array<UInt64> = [],
        let skipEmptyLines!: Bool = false
    ) {
        match (header) {
            case FirstRow =>
                isHeaderInitialized = false
                isHeaderRow = true
            case Override(title) =>
                isHeaderInitialized = true
                isHeaderRow = true
                this.header.add(all: title)
            case Custom(title) =>
                isHeaderInitialized = true
                isHeaderRow = false
                this.header.add(all: title)
        }
    }

    prop data: ArrayList<HashMap<String, String>> {
        get() { _data }
    }

    private prop isBufferOut: Bool {
        get() {
            match (buffer) {
                case None => true
                case Some(buf) => bufferStartIdx >= buf.size
            }
        }
    }

    private prop isAtLineStart: Bool {
        get() { currentRawColumnIdx == 0 && currentColumnData.isEmpty() && !isQuoted && !isCommented }
    }

    /**
     * Parses input lines/rows, incrementally appening parsed columns to data
     */
    func parseIncrementally(input: Array<Rune>) {
        updateBuffer(input)
        readUntilEnd()
    }

    /**
     * Finishes current row if there is no line ending at the buffer end
     */
    func flush() {
        // finish quoted column
        if (let Some(buf) <- buffer) {
            if (isQuoted && buf.hasIndex(bufferStartIdx) && buf[bufferStartIdx] == quoteChar) {
                parseIncrementally(r'\n')
            }
        }

        // finish unquoted column
        if (!currentColumnData.isEmpty() || !currentRowData.isEmpty()) {
            parseIncrementally(r'\n')
        }
    }

    private func updateBuffer(newData: Array<Rune>) {
        buffer = match (buffer) {
            case Some(buf) =>
                let unreadBufSize = buf.size - bufferStartIdx
                let newBuffer = Array<Rune>(unreadBufSize + newData.size, repeat: Rune(0))
                buf.copyTo(newBuffer, bufferStartIdx, 0, unreadBufSize)
                newData.copyTo(newBuffer, 0, unreadBufSize, newData.size)
                newBuffer
            case None => newData
        }
        bufferStartIdx = 0
    }

    /**
     * Reads csv until buffer ends
     */
    private func readUntilEnd() {
        while (!isBufferOut) {
            match {
                case skipRows.contains(currentRowIdx) => if (!skipRow()) {
                    break
                }
                case isHeaderRow => if (readHeader()) {
                    isHeaderRow = false
                } else {
                    break
                }
                case _ => if (readDataRow() && !currentRowData.isEmpty()) {
                    _data.add(currentRowData)
                    currentRowData = HashMap()
                } else {
                    break
                }
            }

            currentRowIdx++
        }

        if (isBufferOut) {
            buffer = None
            bufferStartIdx = 0
        }
    }

    private func shouldBeEscaped(c: Rune): Bool {
        c == escapeChar || c == quoteChar
    }

    /**
     * Reads current column from the buffer to currentColumnData.
     *
     * @return true, if column has read and completed (new line has met), and false in case of buffer has run out before.
     */
    private func readColumn(): Bool {
        let buf = buffer ?? return false
        for (i in bufferStartIdx..buf.size) {
            let c = buf[i]
            match {
                // comment
                case isCommented && buf.isNewLine(at: i) => isCommented = false
                case isCommented => continue
                case isAtLineStart && Some(c) == commentChar => isCommented = true
                // empty line
                case isAtLineStart && skipEmptyLines && buf.isNewLine(at: i) => continue
                // escape in quote
                case isEscaped && shouldBeEscaped(c) =>
                    currentColumnData.add(c)
                    isEscaped = false
                // in case of ambiguity between quote/escape char
                case c == escapeChar && c == quoteChar && isQuoted && !buf.hasIndex(i + 1) =>
                    bufferStartIdx = i
                    return false
                case c == escapeChar && isQuoted && buf.hasIndex(i + 1) && shouldBeEscaped(buf[i + 1]) =>
                    isEscaped = true
                    continue
                // quote
                case c == quoteChar && isQuoted =>
                    isQuoted = false
                    let nextIdx = i + 1
                    bufferStartIdx = nextIdx
                    return true
                case i == bufferStartIdx && c == quoteChar =>
                    isQuoted = true
                    continue
                // end of row
                case !isQuoted && !isEscaped && (c == delimiter || buf.isNewLine(at: i)) =>
                    bufferStartIdx = i
                    return true
                // row's char
                case _ => currentColumnData.add(c)
            }
        }

        bufferStartIdx = buf.size
        return false
    }

    /**
     * Reads current row and applies withColumn to every column of it.
     *
     * @return true if row has finished, and false in case of row has not finished until the buffer end
     */
    private func readRow(withColumn: (String) -> Unit): Bool {
        let buf = buffer ?? return false
        while (readColumn()) {
            if (!skipColumns.contains(currentRawColumnIdx)) {
                withColumn(String(currentColumnData))
            }
            currentColumnData = ArrayList()

            let nextBufferIdx = bufferStartIdx
            match {
                case isBufferOut => return false
                case buf[nextBufferIdx] == delimiter =>
                    if (!skipColumns.contains(currentRawColumnIdx)) {
                        currentColumnIdx++
                    }
                    currentRawColumnIdx++
                    bufferStartIdx++
                case buf.isLF(at: nextBufferIdx) =>
                    currentColumnIdx = 0
                    currentRawColumnIdx = 0
                    bufferStartIdx++
                    return true
                case buf.isCRLF(at: nextBufferIdx) =>
                    currentColumnIdx = 0
                    currentRawColumnIdx = 0
                    bufferStartIdx += 2
                    return true
                case _ => throw IllegalStateException("Unexpected character: '${buf[nextBufferIdx]}' after a column")
            }
        }

        false
    }

    private func readHeader(): Bool {
        let rowFinished = readRow {
            title => if (!isHeaderInitialized) {
                header.add(title)
            }
        }
        if (rowFinished) {
            isHeaderInitialized = true
        }
        rowFinished
    }

    private func readDataRow(): Bool {
        let rowFinished = readRow {
            column =>
            if (currentColumnIdx >= UInt64(header.size)) {
                throw IllegalStateException(
                    "Expected ${header.size} columns in ${currentRowIdx + 1}'th row, but found one more: \"${String(currentColumnData)}\"")
            }
            currentRowData[header[Int64(currentColumnIdx)]] = column
        }

        if (rowFinished && currentRowData.size != header.size) {
            throw IllegalStateException(
                "Expected ${header.size} columns in ${currentRowIdx + 1}'th row, but found ${currentRowData.size}")
        }

        rowFinished
    }

    /**
     * Skips current row.
     *
     * @return true if row has finished, and false in case of row has not finished until the buffer end
     */
    private func skipRow(): Bool {
        readRow {_ =>}
    }
}

extend CsvParser {
    func parse(path: Path) {
        try (file = File(path, Read)) {
            for (line in file.lines()) {
                parseIncrementally(line.toRuneArray())
            }
        }
        flush()
        data
    }
}

extend Array<Rune> {
    func hasIndex(idx: Int64) {
        0 <= idx && idx < this.size
    }

    func isCRLF(at!: Int64) {
        hasIndex(at) && hasIndex(at + 1) && this[at..=at + 1] as Array<Rune> == [r'\r', r'\n']
    }

    func isLF(at!: Int64) {
        hasIndex(at) && this[at] == r'\n'
    }

    func isNewLine(at!: Int64) {
        isLF(at: at) || isCRLF(at: at)
    }
}

class LineIterator<T> <: Iterator<String> where T <: InputStream {
    LineIterator(protected let reader: StringReader<T>) {}

    init(stream: T) {
        this.reader = StringReader(stream)
    }

    public override func next(): ?String {
        this.reader.readUntil(r'\n')
    }
}

extend<T> LineIterator<T> <: Resource where T <: Resource {
    public func isClosed() {
        this.reader.isClosed()
    }

    public func close() {
        this.reader.close()
    }
}

extend File {
    func lines(): LineIterator<File> {
        LineIterator(this)
    }
}

public class CsvStrategy<T> <: DataStrategy<T> where T <: Serializable<T> {
    CsvStrategy(let data: ArrayList<HashMap<String, String>>) {}

    init(
        fileName: String,
        delimiter!: Rune,
        quoteChar!: Rune,
        escapeChar!: Rune,
        commentChar!: Option<Rune>,
        header!: Option<Array<String>>,
        skipRows!: Array<UInt64>,
        skipColumns!: Array<UInt64>,
        skipEmptyLines!: Bool
    ) {
        let actualHeader = match (header) {
            case None => Header.FirstRow
            case Some(actual) where skipRows.contains(0) => Header.Override(actual)
            case Some(actual) => Header.Custom(actual)
        }
        let actualSkipRows = match (actualHeader) {
            case Override(_) =>
                let actualSkip = ArrayList(skipRows)
                actualSkip.removeIf {r: UInt64 => r == 0}
                actualSkip.toArray()
            case _ => skipRows
        }

        let parser = CsvParser(
            header: actualHeader,
            delimiter: delimiter,
            quoteChar: quoteChar,
            escapeChar: escapeChar,
            commentChar: commentChar,
            skipRows: actualSkipRows,
            skipColumns: skipColumns,
            skipEmptyLines: skipEmptyLines
        )

        this.data = parser.parse(Path(fileName))
    }

    public override func provider(_: Configuration): SerializableProvider<T> {
        let dm = DataModelSeq()

        for (row in data) {
            dm.add(row.serialize())
        }

        SerializableProvider(dm)
    }
}

enum Header {
    /* Treat the first row as a header */
    | FirstRow
    /* Treat the first row as a header, but override it with specified one */
    | Override(Array<String>)
    /* Do not treat the first row as a header, use specified one */
    | Custom(Array<String>)
}

/**
 * @return DataStrategy for CSV rows data.
 *
 * @param fileName CSV file path
 * @param delimiter character is used as fields separator in a row
 * @param quoteChar character is used to enclose fields
 * @param escapeChar character is used to escape quoteChar
 * @param commentChar character is used to specify lines to be skipped. It should be the leftmost character in a line
 * @param header a way to override a header row
 *      * If header is specified, the first row of a file will be treated as a data row, and specified header will be used
 *      * If header is specified and row with index 0 is skipped via `skipRows`,
 *        then the first row of a file will be treated as a header, but it will be overridden with specified one
 *      * If header is not set (None), then the first row of a file will be treated as a header. Default value
 * @param skipRows indices of rows to be skipped (zero-indexed)
 * @param skipColumns indices of columns to be skipped (zero-indexed)
 *      If any column is skipped and the `header` is specified, then this header will be applied to actual data columns
 * @param skipEmptyLines specifies should empty lines be skipped or not
 */
public func csv<T>(
    fileName: String,
    delimiter!: Rune = CSV_DEFAULT_DELIMITER,
    quoteChar!: Rune = CSV_DEFAULT_QUOTE,
    escapeChar!: Rune = CSV_DEFAULT_ESCAPE,
    commentChar!: Option<Rune> = None,
    header!: Option<Array<String>> = None,
    skipRows!: Array<UInt64> = [],
    skipColumns!: Array<UInt64> = [],
    skipEmptyLines!: Bool = false
): CsvStrategy<T> where T <: Serializable<T> {
    CsvStrategy<T>(
        fileName,
        delimiter: delimiter,
        quoteChar: quoteChar,
        escapeChar: escapeChar,
        commentChar: commentChar,
        header: header,
        skipRows: skipRows,
        skipColumns: skipColumns,
        skipEmptyLines: skipEmptyLines
    )
}

/**
 * @return DataStrategy for TSV (tab-separated values) rows data.
 *
 * @param fileName TSV file path
 * @param quoteChar character is used to enclose fields
 * @param escapeChar character is used to escape quoteChar
 * @param commentChar character is used to specify lines to be skipped. It should be the leftmost character in a line
 * @param header a way to override a header row
 *      * If header is specified, the first row of a file will be treated as a data row, and specified header will be used
 *      * If header is specified and row with index 0 is skipped via `skipRows`,
 *        then the first row of a file will be treated as a header, but it will be overridden with specified one
 *      * If header is not set (None), then the first row of a file will be treated as a header. Default value
 * @param skipRows indices of rows to be skipped (zero-indexed)
 * @param skipColumns indices of columns to be skipped (zero-indexed)
 *      If any column is skipped and the `header` is specified, then this header will be applied to actual data columns
 * @param skipEmptyLines specifies should empty lines be skipped or not
 */
public func tsv<T>(
    fileName: String,
    quoteChar!: Rune = CSV_DEFAULT_QUOTE,
    escapeChar!: Rune = CSV_DEFAULT_ESCAPE,
    commentChar!: Option<Rune> = None,
    header!: Option<Array<String>> = None,
    skipRows!: Array<UInt64> = [],
    skipColumns!: Array<UInt64> = [],
    skipEmptyLines!: Bool = false
): CsvStrategy<T> where T <: Serializable<T> {
    CsvStrategy<T>(
        fileName,
        delimiter: TSV_DELIMITER,
        quoteChar: quoteChar,
        escapeChar: escapeChar,
        commentChar: commentChar,
        header: header,
        skipRows: skipRows,
        skipColumns: skipColumns,
        skipEmptyLines: skipEmptyLines
    )
}
